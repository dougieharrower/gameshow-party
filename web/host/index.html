<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Host</title>
    <style>
      body {
        font-family: system-ui, Arial, sans-serif;
        margin: 24px;
      }
      .row {
        display: flex;
        gap: 24px;
        align-items: flex-start;
        flex-wrap: wrap;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 16px;
        width: 360px;
      }
      .wide {
        width: 360px;
      }
      .code {
        font-size: 48px;
        letter-spacing: 6px;
        font-weight: 800;
      }
      button {
        padding: 10px 14px;
        cursor: pointer;
        margin-right: 8px;
      }
      ul {
        margin: 8px 0 0;
        padding-left: 18px;
      }
      .muted {
        color: #666;
      }
      .spacer {
        margin-top: 12px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      .danger {
        border: 1px solid #d33;
      }
      .pill {
        display: inline-block;
        padding: 4px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 12px;
        margin-right: 6px;
        margin-top: 6px;
      }
      .hud {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }
      .kv {
        display: flex;
        justify-content: space-between;
        gap: 12px;
      }
      .kv .k {
        color: #666;
      }
      .kv .v {
        font-weight: 700;
      }
      .hr {
        height: 1px;
        background: #eee;
        margin: 12px 0;
      }
      .timer {
        font-weight: 800;
        letter-spacing: 0.3px;
      }

      /* options UI */
      .row2 {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .label {
        font-size: 13px;
        color: #333;
        font-weight: 650;
      }
      .hint {
        font-size: 12px;
        color: #666;
        margin-top: 6px;
      }
      select,
      input[type="checkbox"] {
        cursor: pointer;
      }
      .lock {
        display: none;
        margin-top: 10px;
        padding: 10px;
        border: 1px dashed #bbb;
        border-radius: 8px;
        background: #fafafa;
        color: #444;
      }
      .playerRow {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: center;
        margin: 6px 0;
      }
      .playerLeft {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .playerName {
        font-weight: 700;
      }
      .playerMeta {
        font-size: 12px;
        color: #666;
      }
      .kickBtn {
        padding: 6px 10px;
        border: 1px solid #d33;
        border-radius: 8px;
        background: #fff;
        color: #a00;
      }
      .kickBtn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .pill2 {
        display: inline-block;
        padding: 2px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 12px;
        color: #444;
        margin-left: 6px;
      }

      /* -----------------------
         Final Podium (NEW)
      ------------------------*/
      .finalWrap {
        display: none;
      }
      .finalQuestion {
        font-weight: 750;
        line-height: 1.25;
      }
      .finalGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      .podiumRow {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .podiumName {
        width: 140px;
        font-weight: 700;
        font-size: 13px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }
      .podiumBarOuter {
        flex: 1;
        height: 18px;
        border: 1px solid #ddd;
        border-radius: 999px;
        background: #fafafa;
        overflow: hidden;
      }
      .podiumBarInner {
        height: 100%;
        width: 0%;
        background: #111;
      }
      .podiumPct {
        width: 44px;
        text-align: right;
        font-variant-numeric: tabular-nums;
        color: #444;
        font-size: 12px;
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 12px;
        color: #444;
        margin-left: 6px;
      }
      .badge.answered {
        border-color: #111;
        color: #111;
      }
      .badge.dead {
        border-color: #bbb;
        color: #999;
      }
    </style>
  </head>
  <body>
    <h1>Host</h1>

    <div class="row">
      <!-- ROOM / STATE -->
      <div class="card">
        <div class="muted">Room</div>
        <div id="roomCode" class="code">----</div>

        <div class="muted spacer">
          State: <span id="stateLabel">LOBBY</span>
          <span id="gameStatusPill" class="pill2">lobby</span>
        </div>

        <div class="spacer">
          <button id="btnCreate">Create Game</button>
          <button id="btnStart" disabled>Start Game</button>
        </div>

        <div class="spacer">
          <button id="btnEnd" class="danger" disabled>End Game</button>
        </div>

        <div id="status" class="muted spacer"></div>

        <div id="optionsLockedNotice" class="lock">
          Options are locked once the game starts.
        </div>
      </div>

      <!-- OPTIONS (LOBBY ONLY) -->
      <div class="card" id="optionsCard">
        <div class="muted">Options</div>

        <div class="spacer">
          <div class="row2">
            <span class="label">Family filter</span>
            <label
              class="muted"
              style="display: flex; gap: 8px; align-items: center"
            >
              <input id="optFamily" type="checkbox" />
              <span id="optFamilyLabel">Off</span>
            </label>
          </div>
          <div class="hint">
            Filters content pools (questions/prompts) based on rating.
          </div>
        </div>

        <div class="hr"></div>

        <div class="spacer">
          <div class="row2">
            <span class="label">Middle rounds</span>
            <select id="optMiddleCount">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
            <span class="muted" id="middleCapHint"></span>
          </div>
          <div class="hint">
            Round 1 is always Fastest Finger. Final round is always Podium.
            Middle rounds are randomly selected from available game types (as
            you add them).
          </div>
        </div>

        <div class="hr"></div>

        <div class="muted spacer">Kick players (lobby only)</div>
        <div id="kickList" class="spacer"></div>

        <div class="hint" id="kickHint">
          Kicked players can’t rejoin this room.
        </div>
      </div>

      <!-- ROUND 1 HUD -->
      <div class="card">
        <div class="muted">Round 1</div>

        <div class="hud spacer">
          <div class="kv">
            <div class="k">Block</div>
            <div class="v" id="r1Block">—</div>
          </div>
          <div class="kv">
            <div class="k">Category</div>
            <div class="v" id="r1Category">—</div>
          </div>
          <div class="kv">
            <div class="k">Chooser</div>
            <div class="v" id="r1Chooser">—</div>
          </div>

          <div class="kv">
            <div class="k">Question Timer</div>
            <div class="v timer" id="r1QuestionTimer">—</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="muted">Category Pick</div>
        <div id="r1PickStatus" class="muted spacer">(not active)</div>
        <div id="r1PickOptions" class="spacer"></div>
      </div>

      <!-- PLAYERS / FASTEST -->
      <div class="card">
        <div class="muted">Players</div>
        <ul id="playerList"></ul>

        <div class="muted spacer">Fastest Finger</div>
        <div id="fastestStatus" class="muted">(not started)</div>
        <div id="fastestMeta" class="muted mono"></div>

        <div class="muted spacer">Last Result</div>
        <div id="lastResult" class="muted mono">(none)</div>
      </div>

      <!-- FINAL PODIUM (NEW) -->
      <div class="card finalWrap" id="finalCard">
        <div class="muted">Final Podium</div>

        <div class="hud spacer">
          <div class="kv">
            <div class="k">Phase</div>
            <div class="v" id="finalPhase">—</div>
          </div>
          <div class="kv">
            <div class="k">Timer</div>
            <div class="v timer" id="finalTimer">—</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="muted">Question</div>
        <div id="finalQuestion" class="finalQuestion spacer">(waiting)</div>

        <div class="hr"></div>

        <div class="muted">Podiums</div>
        <div id="finalPodiums" class="finalGrid"></div>

        <div class="hr"></div>

        <div class="muted">Final Log</div>
        <div id="finalLog" class="muted mono spacer">(none)</div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      const roomCodeEl = document.getElementById("roomCode");
      const btnCreate = document.getElementById("btnCreate");
      const btnStart = document.getElementById("btnStart");
      const btnEnd = document.getElementById("btnEnd");

      const playerListEl = document.getElementById("playerList");
      const statusEl = document.getElementById("status");
      const stateLabelEl = document.getElementById("stateLabel");
      const fastestStatusEl = document.getElementById("fastestStatus");
      const fastestMetaEl = document.getElementById("fastestMeta");
      const lastResultEl = document.getElementById("lastResult");

      const r1BlockEl = document.getElementById("r1Block");
      const r1CategoryEl = document.getElementById("r1Category");
      const r1ChooserEl = document.getElementById("r1Chooser");
      const r1PickStatusEl = document.getElementById("r1PickStatus");
      const r1PickOptionsEl = document.getElementById("r1PickOptions");
      const r1QuestionTimerEl = document.getElementById("r1QuestionTimer");

      // options elements
      const optionsCardEl = document.getElementById("optionsCard");
      const optionsLockedNoticeEl = document.getElementById(
        "optionsLockedNotice"
      );
      const gameStatusPillEl = document.getElementById("gameStatusPill");

      const optFamilyEl = document.getElementById("optFamily");
      const optFamilyLabelEl = document.getElementById("optFamilyLabel");
      const optMiddleCountEl = document.getElementById("optMiddleCount");
      const middleCapHintEl = document.getElementById("middleCapHint");

      const kickListEl = document.getElementById("kickList");

      // FINAL elements
      const finalCardEl = document.getElementById("finalCard");
      const finalPhaseEl = document.getElementById("finalPhase");
      const finalTimerEl = document.getElementById("finalTimer");
      const finalQuestionEl = document.getElementById("finalQuestion");
      const finalPodiumsEl = document.getElementById("finalPodiums");
      const finalLogEl = document.getElementById("finalLog");

      let currentRoomCode = null;

      // countdown deadlines (epoch ms)
      let pickEndsAt = null;
      let questionEndsAt = null;

      // FINAL countdown
      let finalEndsAt = null;

      // pick UI helper
      let pickStatusBaseText = "(not active)";
      let pickActive = false;

      // options + status
      let gameStatus = "lobby"; // "lobby" | "in_progress" | "finished"
      let roomOptions = {
        contentRating: "standard",
        middleCount: 0,
        selectedMiddleGames: null,
      };
      let availableMiddleGames = [];

      // FINAL state cache (for render)
      let finalState = {
        phase: null,
        prompt: null,
        heights: {},
        alivePlayerIds: [],
        answered: {},
      };

      function setStateLabel(state) {
        stateLabelEl.textContent = state || "UNKNOWN";
      }

      function setGameStatus(next) {
        gameStatus = next || "lobby";
        gameStatusPillEl.textContent = gameStatus;
        const inLobby = gameStatus === "lobby";

        optionsCardEl.style.display = inLobby ? "block" : "none";
        optionsLockedNoticeEl.style.display = inLobby ? "none" : "block";

        optFamilyEl.disabled = !inLobby;
        optMiddleCountEl.disabled = !inLobby;
      }

      function renderPlayers(players) {
        playerListEl.innerHTML = "";
        if (!players || players.length === 0) {
          const li = document.createElement("li");
          li.textContent = "(no players yet)";
          li.className = "muted";
          playerListEl.appendChild(li);
          return;
        }

        const sorted = [...players].sort(
          (a, b) => (b.score ?? 0) - (a.score ?? 0)
        );

        sorted.forEach((p) => {
          const li = document.createElement("li");
          const score = p.score ?? 0;
          const conn = p.isConnected === false ? " (offline)" : "";
          const avatar = p.avatarId ? `[${p.avatarId}] ` : "";
          li.textContent = `${avatar}${p.displayName}${conn} — ${score}`;
          playerListEl.appendChild(li);
        });

        renderKickList(sorted);
      }

      function renderKickList(players) {
        kickListEl.innerHTML = "";
        if (gameStatus !== "lobby") {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "(locked once game starts)";
          kickListEl.appendChild(div);
          return;
        }

        if (!players || players.length === 0) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "(no players to kick)";
          kickListEl.appendChild(div);
          return;
        }

        players.forEach((p) => {
          const row = document.createElement("div");
          row.className = "playerRow";

          const left = document.createElement("div");
          left.className = "playerLeft";

          const name = document.createElement("div");
          name.className = "playerName";
          name.textContent = p.displayName;

          const meta = document.createElement("div");
          meta.className = "playerMeta";
          meta.textContent = `${p.avatarId ? "[" + p.avatarId + "] " : ""}${
            p.isConnected === false ? "offline" : "online"
          } • score ${p.score ?? 0}`;

          left.appendChild(name);
          left.appendChild(meta);

          const btn = document.createElement("button");
          btn.className = "kickBtn";
          btn.textContent = "Kick";
          btn.disabled = !currentRoomCode || gameStatus !== "lobby";
          btn.addEventListener("click", () =>
            kickPlayer(p.playerId, p.displayName)
          );

          row.appendChild(left);
          row.appendChild(btn);

          kickListEl.appendChild(row);
        });
      }

      function setR1Hud({
        blockIndex,
        totalBlocks,
        categoryId,
        categoryName,
        chooserDisplayName,
      } = {}) {
        if (Number.isFinite(blockIndex) && Number.isFinite(totalBlocks)) {
          r1BlockEl.textContent = `${blockIndex}/${totalBlocks}`;
        } else {
          r1BlockEl.textContent = "—";
        }

        const cat = categoryName || categoryId || "—";
        r1CategoryEl.textContent = cat;

        r1ChooserEl.textContent = chooserDisplayName || "—";
      }

      function setPickUIActive({ chooserDisplayName, options } = {}) {
        pickActive = true;

        pickStatusBaseText = chooserDisplayName
          ? `Waiting for ${chooserDisplayName} to choose…`
          : "Waiting for chooser…";
        r1PickStatusEl.textContent = pickStatusBaseText;

        r1PickOptionsEl.innerHTML = "";
        (options || []).forEach((opt) => {
          const span = document.createElement("span");
          span.className = "pill";
          span.textContent = opt.name || opt.id || String(opt);
          r1PickOptionsEl.appendChild(span);
        });

        if (!options || options.length === 0) {
          const span = document.createElement("span");
          span.className = "pill";
          span.textContent = "(options pending)";
          r1PickOptionsEl.appendChild(span);
        }
      }

      function setPickUIInactive() {
        pickActive = false;
        pickEndsAt = null;
        pickStatusBaseText = "(not active)";
        r1PickStatusEl.textContent = pickStatusBaseText;
        r1PickOptionsEl.innerHTML = "";
      }

      function setFastestStatus({
        isOpen,
        winner,
        lockedOutPlayerIds,
        answeredPlayerIds,
      } = {}) {
        const lockedOutCount = (lockedOutPlayerIds || []).length;
        const answeredCount = (answeredPlayerIds || []).length;

        if (winner) {
          fastestStatusEl.textContent = `Winner: ${
            winner.displayName || winner.playerId
          } (${winner.choice || "?"})`;
        } else if (isOpen) {
          fastestStatusEl.textContent = "Open — first correct tap wins";
        } else {
          fastestStatusEl.textContent = "(closed)";
        }

        fastestMetaEl.textContent = `attempted=${answeredCount}  lockedOut=${lockedOutCount}`;
      }

      function resetFastestUI() {
        fastestStatusEl.textContent = "(not started)";
        fastestMetaEl.textContent = "";
      }

      function applyOptionsToUI() {
        const isFamily = roomOptions.contentRating === "family";
        optFamilyEl.checked = isFamily;
        optFamilyLabelEl.textContent = isFamily ? "On" : "Off";

        const cap = Math.min(3, availableMiddleGames.length);
        middleCapHintEl.textContent = `(available: ${availableMiddleGames.length}, max: ${cap})`;

        [...optMiddleCountEl.options].forEach((o) => {
          const v = Number(o.value);
          o.disabled = v > cap;
        });

        const current = Number(roomOptions.middleCount) || 0;
        const clamped = Math.max(0, Math.min(current, cap));
        optMiddleCountEl.value = String(clamped);
      }

      function requestOptionsUpdate(partial) {
        if (!currentRoomCode) return;
        if (gameStatus !== "lobby") return;

        socket.emit(
          "host:update_options",
          { roomCode: currentRoomCode, options: partial },
          (ack) => {
            if (!ack?.ok) {
              statusEl.textContent = `Options update failed: ${
                ack?.reason || "UNKNOWN"
              }`;
              applyOptionsToUI();
              return;
            }
            statusEl.textContent = "Options saved.";
          }
        );
      }

      function kickPlayer(playerId, displayName) {
        if (!currentRoomCode) return;
        if (gameStatus !== "lobby") return;

        const ok = confirm(
          `Kick ${
            displayName || "this player"
          }? They won't be able to rejoin this room.`
        );
        if (!ok) return;

        socket.emit(
          "host:kick_player",
          { roomCode: currentRoomCode, playerId },
          (ack) => {
            if (!ack?.ok) {
              statusEl.textContent = `Kick failed: ${ack?.reason || "UNKNOWN"}`;
              return;
            }
            statusEl.textContent = `Kicked ${displayName || "player"}.`;
          }
        );
      }

      function showFinalUI(show) {
        finalCardEl.style.display = show ? "block" : "none";
      }

      function resetFinalUI() {
        finalEndsAt = null;
        finalState = {
          phase: null,
          prompt: null,
          heights: {},
          alivePlayerIds: [],
          answered: {},
        };
        finalPhaseEl.textContent = "—";
        finalTimerEl.textContent = "—";
        finalQuestionEl.textContent = "(waiting)";
        finalPodiumsEl.innerHTML = "";
        finalLogEl.textContent = "(none)";
        showFinalUI(false);
      }

      function playerNameFromList(playerId) {
        // Try to read from current visible list items (best effort), otherwise show id
        return playerId;
      }

      function renderFinalPodiums(players) {
        // players: [{playerId, displayName, ...}] from cached list if we have it
        const alive = new Set(finalState.alivePlayerIds || []);
        const heights = finalState.heights || {};
        const answered = finalState.answered || {};

        // pick an ordering:
        // - alive first, sorted by height desc
        // - then dead, sorted by height desc
        const ids = Object.keys(heights);

        const rows = ids
          .map((pid) => {
            const h = Number.isFinite(heights[pid]) ? heights[pid] : 0;
            const isAlive = alive.has(pid);
            return { pid, h, isAlive };
          })
          .sort((a, b) => {
            if (a.isAlive !== b.isAlive) return a.isAlive ? -1 : 1;
            return (b.h ?? 0) - (a.h ?? 0);
          });

        // map pid -> displayName (from player list)
        const nameMap = {};
        (players || []).forEach((p) => (nameMap[p.playerId] = p.displayName));

        finalPodiumsEl.innerHTML = "";
        if (rows.length === 0) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "(no podium data yet)";
          finalPodiumsEl.appendChild(div);
          return;
        }

        rows.forEach((r) => {
          const pct = clamp01(r.h) * 100;

          const row = document.createElement("div");
          row.className = "podiumRow";

          const name = document.createElement("div");
          name.className = "podiumName";
          name.textContent = nameMap[r.pid] || r.pid;

          const badge = document.createElement("span");
          badge.className = "badge";
          if (!r.isAlive) {
            badge.classList.add("dead");
            badge.textContent = "out";
          } else if (answered[r.pid]) {
            badge.classList.add("answered");
            badge.textContent = "answered";
          } else {
            badge.textContent = "waiting";
          }
          name.appendChild(badge);

          const outer = document.createElement("div");
          outer.className = "podiumBarOuter";

          const inner = document.createElement("div");
          inner.className = "podiumBarInner";
          inner.style.width = `${Math.round(pct)}%`;

          outer.appendChild(inner);

          const pctEl = document.createElement("div");
          pctEl.className = "podiumPct";
          pctEl.textContent = `${Math.round(pct)}%`;

          row.appendChild(name);
          row.appendChild(outer);
          row.appendChild(pctEl);

          finalPodiumsEl.appendChild(row);
        });
      }

      function clamp01(x) {
        x = Number(x);
        if (!Number.isFinite(x)) return 0;
        return Math.max(0, Math.min(1, x));
      }

      function resetUIToLobby() {
        currentRoomCode = null;
        roomCodeEl.textContent = "----";
        btnStart.disabled = true;
        btnEnd.disabled = true;

        pickEndsAt = null;
        questionEndsAt = null;
        r1QuestionTimerEl.textContent = "—";

        setStateLabel("LOBBY");
        setGameStatus("lobby");

        roomOptions = {
          contentRating: "standard",
          middleCount: 0,
          selectedMiddleGames: null,
        };
        availableMiddleGames = [];
        applyOptionsToUI();

        resetFastestUI();
        lastResultEl.textContent = "(none)";
        renderPlayers([]);
        setR1Hud({});
        setPickUIInactive();
        statusEl.textContent = "";

        resetFinalUI();
      }

      // --------------------
      // Countdown render loop
      // --------------------
      function msLeft(endsAt) {
        if (!Number.isFinite(endsAt)) return null;
        return Math.max(0, endsAt - Date.now());
      }

      function fmtSeconds(ms) {
        const s = Math.ceil(ms / 1000);
        return `${s}s`;
      }

      function tickCountdowns() {
        // R1 pick
        if (pickActive && Number.isFinite(pickEndsAt)) {
          const left = msLeft(pickEndsAt);
          if (left == null) {
            r1PickStatusEl.textContent = pickStatusBaseText;
          } else if (left <= 0) {
            r1PickStatusEl.textContent = `${pickStatusBaseText} (auto-picking…)`;
          } else {
            r1PickStatusEl.textContent = `${pickStatusBaseText} (${fmtSeconds(
              left
            )})`;
          }
        } else {
          if (!pickActive) r1PickStatusEl.textContent = pickStatusBaseText;
        }

        // R1 question
        if (Number.isFinite(questionEndsAt)) {
          const left = msLeft(questionEndsAt);
          if (left == null) {
            r1QuestionTimerEl.textContent = "—";
          } else if (left <= 0) {
            r1QuestionTimerEl.textContent = "0s";
          } else {
            r1QuestionTimerEl.textContent = fmtSeconds(left);
          }
        } else {
          r1QuestionTimerEl.textContent = "—";
        }

        // FINAL question
        if (Number.isFinite(finalEndsAt)) {
          const left = msLeft(finalEndsAt);
          if (left == null) {
            finalTimerEl.textContent = "—";
          } else if (left <= 0) {
            finalTimerEl.textContent = "0s";
          } else {
            finalTimerEl.textContent = fmtSeconds(left);
          }
        } else {
          finalTimerEl.textContent = "—";
        }
      }

      setInterval(tickCountdowns, 100);

      // --------------------
      // Refresh warning (kills game)
      // --------------------
      window.addEventListener("beforeunload", (e) => {
        if (currentRoomCode) {
          e.preventDefault();
          e.returnValue =
            "Refreshing or closing will end the current game for everyone.";
        }
      });

      // --------------------
      // Create Room
      // --------------------
      btnCreate.addEventListener("click", () => {
        statusEl.textContent = "Creating room...";
        resetFastestUI();
        lastResultEl.textContent = "(none)";
        btnStart.disabled = true;
        btnEnd.disabled = true;
        setR1Hud({});
        setPickUIInactive();

        pickEndsAt = null;
        questionEndsAt = null;

        resetFinalUI();

        socket.emit("host:create_room", { maxPlayers: 6 }, (ack) => {
          if (!ack?.ok) {
            statusEl.textContent = "Failed to create room.";
            return;
          }

          currentRoomCode = ack.roomCode;
          roomCodeEl.textContent = ack.roomCode;
          btnStart.disabled = false;
          btnEnd.disabled = false;

          setStateLabel("LOBBY");
          setGameStatus("lobby");
          statusEl.textContent = "Room created. Players can join now.";
          renderPlayers([]);
        });
      });

      // --------------------
      // Start Game
      // --------------------
      btnStart.addEventListener("click", () => {
        if (!currentRoomCode) return;

        statusEl.textContent = "Starting game...";
        socket.emit("host:start_game", { roomCode: currentRoomCode }, (ack) => {
          if (!ack?.ok) {
            statusEl.textContent = `Start failed: ${ack?.reason || "UNKNOWN"}`;
            return;
          }
          statusEl.textContent = "Game started.";
        });
      });

      // --------------------
      // End Game
      // --------------------
      btnEnd.addEventListener("click", () => {
        if (!currentRoomCode) return;

        const ok = confirm(
          "End the game for everyone? (Phones will be booted)"
        );
        if (!ok) return;

        statusEl.textContent = "Ending game...";
        socket.emit("host:end_game", { roomCode: currentRoomCode }, (ack) => {
          if (!ack?.ok) {
            statusEl.textContent = `End failed: ${ack?.reason || "UNKNOWN"}`;
            return;
          }
          statusEl.textContent = "Game ended.";
          resetUIToLobby();
        });
      });

      // --------------------
      // Options UI events
      // --------------------
      optFamilyEl.addEventListener("change", () => {
        const next = optFamilyEl.checked ? "family" : "standard";
        optFamilyLabelEl.textContent = optFamilyEl.checked ? "On" : "Off";
        requestOptionsUpdate({ contentRating: next });
      });

      optMiddleCountEl.addEventListener("change", () => {
        const v = Number(optMiddleCountEl.value);
        requestOptionsUpdate({ middleCount: v });
      });

      // --------------------
      // Server Events
      // --------------------
      let lastPlayersPayload = [];

      socket.on("server:player_list_updated", ({ players }) => {
        lastPlayersPayload = players || [];
        renderPlayers(players);

        // keep final podium render in sync if final is on screen
        if (finalCardEl.style.display !== "none") {
          renderFinalPodiums(lastPlayersPayload);
        }
      });

      socket.on("server:options_updated", (payload = {}) => {
        if (
          payload.roomCode &&
          currentRoomCode &&
          payload.roomCode !== currentRoomCode
        )
          return;

        if (payload.gameStatus) setGameStatus(payload.gameStatus);

        if (payload.options) roomOptions = payload.options;
        if (Array.isArray(payload.availableMiddleGames))
          availableMiddleGames = payload.availableMiddleGames;

        applyOptionsToUI();
      });

      socket.on(
        "server:state_changed",
        ({ state, r1, gameStatus: gs, options, roundId, final } = {}) => {
          setStateLabel(state);

          if (gs) setGameStatus(gs);
          if (options) {
            roomOptions = options;
            applyOptionsToUI();
          }

          // FINAL visibility toggle based on state / roundId
          const inFinal =
            roundId === 99 ||
            String(state || "").startsWith("FINAL_") ||
            final != null;

          showFinalUI(!!inFinal);

          if (inFinal) {
            // pull snapshot if present
            if (final) {
              finalState.phase = final.phase || finalState.phase;
              finalPhaseEl.textContent = finalState.phase || "—";

              if (final.prompt) {
                finalState.prompt = final.prompt;
                finalQuestionEl.textContent = final.prompt;
              }

              if (final.endsAt === null) finalEndsAt = null;
              if (Number.isFinite(final.endsAt)) finalEndsAt = final.endsAt;

              if (final.heights) finalState.heights = final.heights;
              if (Array.isArray(final.alivePlayerIds))
                finalState.alivePlayerIds = final.alivePlayerIds;
              if (final.answered) finalState.answered = final.answered;

              renderFinalPodiums(lastPlayersPayload);
            } else {
              // at least set phase from state
              finalPhaseEl.textContent = state || "FINAL";
            }
          } else {
            // leaving final
            resetFinalUI();
          }

          // R1
          if (r1) {
            setR1Hud({
              blockIndex: r1.blockIndex,
              totalBlocks: 4,
              categoryId: r1.currentCategoryId,
              categoryName: r1.currentCategoryName,
              chooserDisplayName: r1.chooserDisplayName,
            });

            if (Number.isFinite(r1.pickEndsAt)) pickEndsAt = r1.pickEndsAt;
            else if (r1.pickEndsAt === null) pickEndsAt = null;

            if (Number.isFinite(r1.questionEndsAt))
              questionEndsAt = r1.questionEndsAt;
            else if (r1.questionEndsAt === null) questionEndsAt = null;
          }

          if (state === "ROUND_1_CATEGORY_PICK" && r1) {
            setPickUIActive({
              chooserDisplayName: r1.chooserDisplayName,
              options: r1.pickOptionsDetailed || [],
            });
          } else {
            setPickUIInactive();
          }
        }
      );

      socket.on("server:r1_fastest_state", (payload) => {
        setFastestStatus(payload);
        if (Number.isFinite(payload?.endsAt)) questionEndsAt = payload.endsAt;
        else if (payload?.endsAt === null) questionEndsAt = null;
      });

      socket.on("server:r1_question_presented", ({ prompt, endsAt }) => {
        lastResultEl.textContent = `Q: ${prompt}`;
        if (Number.isFinite(endsAt)) questionEndsAt = endsAt;
      });

      socket.on(
        "server:r1_answer_locked_out",
        ({ answeringDisplayName, answeringPlayerId, chosen, scoreDelta }) => {
          const who = answeringDisplayName || answeringPlayerId || "Someone";
          lastResultEl.textContent = `${who} LOCKED OUT (${scoreDelta}) — chose ${chosen}`;
        }
      );

      socket.on(
        "server:r1_answer_winner",
        ({ winnerDisplayName, winnerPlayerId, chosen, scoreDelta }) => {
          const who = winnerDisplayName || winnerPlayerId || "Someone";
          lastResultEl.textContent = `${who} WINS (${scoreDelta}) — chose ${chosen}`;
          questionEndsAt = null;
        }
      );

      socket.on(
        "server:r1_answer_timeout",
        ({ correctChoice, scoreDeltaIfNoAttempt }) => {
          lastResultEl.textContent = `TIMEOUT — correct was ${correctChoice} (no-attempt penalty ${scoreDeltaIfNoAttempt})`;
          questionEndsAt = null;
        }
      );

      // --------------------
      // FINAL events (NEW)
      // --------------------
      socket.on(
        "server:final_question_presented",
        ({ prompt, endsAt, heights, alivePlayerIds }) => {
          showFinalUI(true);

          finalState.phase = "question_open";
          finalPhaseEl.textContent = "question_open";

          finalState.prompt = prompt || "(question)";
          finalQuestionEl.textContent = finalState.prompt;

          finalEndsAt = Number.isFinite(endsAt) ? endsAt : null;

          if (heights) finalState.heights = heights;
          if (Array.isArray(alivePlayerIds))
            finalState.alivePlayerIds = alivePlayerIds;

          // reset answered map for this question (server doesn't send it on this event)
          finalState.answered = {};

          renderFinalPodiums(lastPlayersPayload);
          finalLogEl.textContent = `Final Q started (${
            finalEndsAt ? "timed" : "—"
          })`;
        }
      );

      socket.on("server:final_answer_received", ({ playerId, displayName }) => {
        // mark answered in our local snapshot so the host sees "answered"
        finalState.answered = finalState.answered || {};
        finalState.answered[playerId] = { choice: "?" };

        renderFinalPodiums(lastPlayersPayload);

        const who = displayName || playerId || "Someone";
        finalLogEl.textContent = `${who} locked in`;
      });

      socket.on(
        "server:final_reveal",
        ({
          correctChoice,
          firstCorrectDisplayName,
          resultsByPlayerId,
          heights,
          alivePlayerIds,
          reason,
        }) => {
          finalState.phase = "reveal";
          finalPhaseEl.textContent = "reveal";
          finalEndsAt = null;

          if (heights) finalState.heights = heights;
          if (Array.isArray(alivePlayerIds))
            finalState.alivePlayerIds = alivePlayerIds;

          // convert results -> answered map for badges
          const answered = {};
          if (resultsByPlayerId) {
            Object.keys(resultsByPlayerId).forEach((pid) => {
              const r = resultsByPlayerId[pid];
              if (r?.choice) answered[pid] = { choice: r.choice };
            });
          }
          finalState.answered = answered;

          renderFinalPodiums(lastPlayersPayload);

          finalLogEl.textContent =
            `REVEAL — correct ${correctChoice} • first: ${
              firstCorrectDisplayName || "—"
            } • ${reason || ""}`.trim();
        }
      );

      socket.on(
        "server:final_complete",
        ({ winnerDisplayName, winnerPlayerId, heights }) => {
          finalState.phase = "complete";
          finalPhaseEl.textContent = "complete";
          finalEndsAt = null;

          if (heights) finalState.heights = heights;

          renderFinalPodiums(lastPlayersPayload);

          const who = winnerDisplayName || winnerPlayerId || "(no winner)";
          finalLogEl.textContent = `WINNER — ${who}`;
        }
      );

      socket.on("server:error", (err) => {
        statusEl.textContent = `Error: ${err?.code || "UNKNOWN"}`;
        if (err?.code === "ROOM_CLOSED") {
          resetUIToLobby();
        }
      });

      // Initial render
      resetUIToLobby();
    </script>
  </body>
</html>
