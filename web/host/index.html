<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Host</title>
    <style>
      body {
        font-family: system-ui, Arial, sans-serif;
        margin: 24px;
      }
      .row {
        display: flex;
        gap: 24px;
        align-items: flex-start;
        flex-wrap: wrap;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 16px;
        width: 360px;
      }
      .wide {
        width: 360px;
      }
      .code {
        font-size: 48px;
        letter-spacing: 6px;
        font-weight: 800;
      }
      button {
        padding: 10px 14px;
        cursor: pointer;
        margin-right: 8px;
      }
      ul {
        margin: 8px 0 0;
        padding-left: 18px;
      }
      .muted {
        color: #666;
      }
      .spacer {
        margin-top: 12px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      .danger {
        border: 1px solid #d33;
      }
      .pill {
        display: inline-block;
        padding: 4px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 12px;
        margin-right: 6px;
        margin-top: 6px;
      }
      .hud {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }
      .kv {
        display: flex;
        justify-content: space-between;
        gap: 12px;
      }
      .kv .k {
        color: #666;
      }
      .kv .v {
        font-weight: 700;
      }
      .hr {
        height: 1px;
        background: #eee;
        margin: 12px 0;
      }
      .timer {
        font-weight: 800;
        letter-spacing: 0.3px;
      }

      /* NEW: options UI */
      .row2 {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .label {
        font-size: 13px;
        color: #333;
        font-weight: 650;
      }
      .hint {
        font-size: 12px;
        color: #666;
        margin-top: 6px;
      }
      select,
      input[type="checkbox"] {
        cursor: pointer;
      }
      .lock {
        display: none;
        margin-top: 10px;
        padding: 10px;
        border: 1px dashed #bbb;
        border-radius: 8px;
        background: #fafafa;
        color: #444;
      }
      .playerRow {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: center;
        margin: 6px 0;
      }
      .playerLeft {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .playerName {
        font-weight: 700;
      }
      .playerMeta {
        font-size: 12px;
        color: #666;
      }
      .kickBtn {
        padding: 6px 10px;
        border: 1px solid #d33;
        border-radius: 8px;
        background: #fff;
        color: #a00;
      }
      .kickBtn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .pill2 {
        display: inline-block;
        padding: 2px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 12px;
        color: #444;
        margin-left: 6px;
      }
    </style>
  </head>
  <body>
    <h1>Host</h1>

    <div class="row">
      <!-- ROOM / STATE -->
      <div class="card">
        <div class="muted">Room</div>
        <div id="roomCode" class="code">----</div>

        <div class="muted spacer">
          State: <span id="stateLabel">LOBBY</span>
          <span id="gameStatusPill" class="pill2">lobby</span>
        </div>

        <div class="spacer">
          <button id="btnCreate">Create Game</button>
          <button id="btnStart" disabled>Start Game</button>
        </div>

        <div class="spacer">
          <button id="btnEnd" class="danger" disabled>End Game</button>
        </div>

        <div id="status" class="muted spacer"></div>

        <div id="optionsLockedNotice" class="lock">
          Options are locked once the game starts.
        </div>
      </div>

      <!-- OPTIONS (LOBBY ONLY) -->
      <div class="card" id="optionsCard">
        <div class="muted">Options</div>

        <div class="spacer">
          <div class="row2">
            <span class="label">Family filter</span>
            <label
              class="muted"
              style="display: flex; gap: 8px; align-items: center"
            >
              <input id="optFamily" type="checkbox" />
              <span id="optFamilyLabel">Off</span>
            </label>
          </div>
          <div class="hint">
            Filters content pools (questions/prompts) based on rating.
          </div>
        </div>

        <div class="hr"></div>

        <div class="spacer">
          <div class="row2">
            <span class="label">Middle rounds</span>
            <select id="optMiddleCount">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
            </select>
            <span class="muted" id="middleCapHint"></span>
          </div>
          <div class="hint">
            Round 1 is always Fastest Finger. Final round is always Podium.
            Middle rounds are randomly selected from available game types (as
            you add them).
          </div>
        </div>

        <div class="hr"></div>

        <div class="muted spacer">Kick players (lobby only)</div>
        <div id="kickList" class="spacer"></div>

        <div class="hint" id="kickHint">
          Kicked players can’t rejoin this room.
        </div>
      </div>

      <!-- ROUND 1 HUD -->
      <div class="card">
        <div class="muted">Round 1</div>

        <div class="hud spacer">
          <div class="kv">
            <div class="k">Block</div>
            <div class="v" id="r1Block">—</div>
          </div>
          <div class="kv">
            <div class="k">Category</div>
            <div class="v" id="r1Category">—</div>
          </div>
          <div class="kv">
            <div class="k">Chooser</div>
            <div class="v" id="r1Chooser">—</div>
          </div>

          <div class="kv">
            <div class="k">Question Timer</div>
            <div class="v timer" id="r1QuestionTimer">—</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="muted">Category Pick</div>
        <div id="r1PickStatus" class="muted spacer">(not active)</div>
        <div id="r1PickOptions" class="spacer"></div>
      </div>

      <!-- PLAYERS / FASTEST -->
      <div class="card">
        <div class="muted">Players</div>
        <ul id="playerList"></ul>

        <div class="muted spacer">Fastest Finger</div>
        <div id="fastestStatus" class="muted">(not started)</div>
        <div id="fastestMeta" class="muted mono"></div>

        <div class="muted spacer">Last Result</div>
        <div id="lastResult" class="muted mono">(none)</div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      const roomCodeEl = document.getElementById("roomCode");
      const btnCreate = document.getElementById("btnCreate");
      const btnStart = document.getElementById("btnStart");
      const btnEnd = document.getElementById("btnEnd");

      const playerListEl = document.getElementById("playerList");
      const statusEl = document.getElementById("status");
      const stateLabelEl = document.getElementById("stateLabel");
      const fastestStatusEl = document.getElementById("fastestStatus");
      const fastestMetaEl = document.getElementById("fastestMeta");
      const lastResultEl = document.getElementById("lastResult");

      const r1BlockEl = document.getElementById("r1Block");
      const r1CategoryEl = document.getElementById("r1Category");
      const r1ChooserEl = document.getElementById("r1Chooser");
      const r1PickStatusEl = document.getElementById("r1PickStatus");
      const r1PickOptionsEl = document.getElementById("r1PickOptions");
      const r1QuestionTimerEl = document.getElementById("r1QuestionTimer");

      // NEW: options elements
      const optionsCardEl = document.getElementById("optionsCard");
      const optionsLockedNoticeEl = document.getElementById(
        "optionsLockedNotice"
      );
      const gameStatusPillEl = document.getElementById("gameStatusPill");

      const optFamilyEl = document.getElementById("optFamily");
      const optFamilyLabelEl = document.getElementById("optFamilyLabel");
      const optMiddleCountEl = document.getElementById("optMiddleCount");
      const middleCapHintEl = document.getElementById("middleCapHint");

      const kickListEl = document.getElementById("kickList");

      let currentRoomCode = null;

      // countdown deadlines (epoch ms)
      let pickEndsAt = null;
      let questionEndsAt = null;

      // pick UI helper
      let pickStatusBaseText = "(not active)";
      let pickActive = false;

      // NEW: options + status
      let gameStatus = "lobby"; // "lobby" | "in_progress" | "finished"
      let roomOptions = {
        contentRating: "standard",
        middleCount: 0,
        selectedMiddleGames: null,
      };
      let availableMiddleGames = [];

      function setStateLabel(state) {
        stateLabelEl.textContent = state || "UNKNOWN";
      }

      function setGameStatus(next) {
        gameStatus = next || "lobby";
        gameStatusPillEl.textContent = gameStatus;
        const inLobby = gameStatus === "lobby";

        // Options screen inaccessible once started
        optionsCardEl.style.display = inLobby ? "block" : "none";
        optionsLockedNoticeEl.style.display = inLobby ? "none" : "block";

        // Also disable kick controls if we ever decide to leave it visible
        // (currently we fully hide, but keep safe)
        optFamilyEl.disabled = !inLobby;
        optMiddleCountEl.disabled = !inLobby;
      }

      function renderPlayers(players) {
        playerListEl.innerHTML = "";
        if (!players || players.length === 0) {
          const li = document.createElement("li");
          li.textContent = "(no players yet)";
          li.className = "muted";
          playerListEl.appendChild(li);
          return;
        }

        const sorted = [...players].sort(
          (a, b) => (b.score ?? 0) - (a.score ?? 0)
        );

        sorted.forEach((p) => {
          const li = document.createElement("li");
          const score = p.score ?? 0;
          const conn = p.isConnected === false ? " (offline)" : "";
          const avatar = p.avatarId ? `[${p.avatarId}] ` : "";
          li.textContent = `${avatar}${p.displayName}${conn} — ${score}`;
          playerListEl.appendChild(li);
        });

        // Keep kick list in sync
        renderKickList(sorted);
      }

      function renderKickList(players) {
        kickListEl.innerHTML = "";
        if (gameStatus !== "lobby") {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "(locked once game starts)";
          kickListEl.appendChild(div);
          return;
        }

        if (!players || players.length === 0) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "(no players to kick)";
          kickListEl.appendChild(div);
          return;
        }

        players.forEach((p) => {
          const row = document.createElement("div");
          row.className = "playerRow";

          const left = document.createElement("div");
          left.className = "playerLeft";

          const name = document.createElement("div");
          name.className = "playerName";
          name.textContent = p.displayName;

          const meta = document.createElement("div");
          meta.className = "playerMeta";
          meta.textContent = `${p.avatarId ? "[" + p.avatarId + "] " : ""}${
            p.isConnected === false ? "offline" : "online"
          } • score ${p.score ?? 0}`;

          left.appendChild(name);
          left.appendChild(meta);

          const btn = document.createElement("button");
          btn.className = "kickBtn";
          btn.textContent = "Kick";
          btn.disabled = !currentRoomCode || gameStatus !== "lobby";
          btn.addEventListener("click", () =>
            kickPlayer(p.playerId, p.displayName)
          );

          row.appendChild(left);
          row.appendChild(btn);

          kickListEl.appendChild(row);
        });
      }

      function setR1Hud({
        blockIndex,
        totalBlocks,
        categoryId,
        categoryName,
        chooserDisplayName,
      } = {}) {
        if (Number.isFinite(blockIndex) && Number.isFinite(totalBlocks)) {
          r1BlockEl.textContent = `${blockIndex}/${totalBlocks}`;
        } else {
          r1BlockEl.textContent = "—";
        }

        const cat = categoryName || categoryId || "—";
        r1CategoryEl.textContent = cat;

        r1ChooserEl.textContent = chooserDisplayName || "—";
      }

      function setPickUIActive({ chooserDisplayName, options } = {}) {
        pickActive = true;

        pickStatusBaseText = chooserDisplayName
          ? `Waiting for ${chooserDisplayName} to choose…`
          : "Waiting for chooser…";
        r1PickStatusEl.textContent = pickStatusBaseText;

        r1PickOptionsEl.innerHTML = "";
        (options || []).forEach((opt) => {
          const span = document.createElement("span");
          span.className = "pill";
          span.textContent = opt.name || opt.id || String(opt);
          r1PickOptionsEl.appendChild(span);
        });

        if (!options || options.length === 0) {
          const span = document.createElement("span");
          span.className = "pill";
          span.textContent = "(options pending)";
          r1PickOptionsEl.appendChild(span);
        }
      }

      function setPickUIInactive() {
        pickActive = false;
        pickEndsAt = null;
        pickStatusBaseText = "(not active)";
        r1PickStatusEl.textContent = pickStatusBaseText;
        r1PickOptionsEl.innerHTML = "";
      }

      function setFastestStatus({
        isOpen,
        winner,
        lockedOutPlayerIds,
        answeredPlayerIds,
      } = {}) {
        const lockedOutCount = (lockedOutPlayerIds || []).length;
        const answeredCount = (answeredPlayerIds || []).length;

        if (winner) {
          fastestStatusEl.textContent = `Winner: ${
            winner.displayName || winner.playerId
          } (${winner.choice || "?"})`;
        } else if (isOpen) {
          fastestStatusEl.textContent = "Open — first correct tap wins";
        } else {
          fastestStatusEl.textContent = "(closed)";
        }

        fastestMetaEl.textContent = `attempted=${answeredCount}  lockedOut=${lockedOutCount}`;
      }

      function resetFastestUI() {
        fastestStatusEl.textContent = "(not started)";
        fastestMetaEl.textContent = "";
      }

      function applyOptionsToUI() {
        // contentRating -> checkbox
        const isFamily = roomOptions.contentRating === "family";
        optFamilyEl.checked = isFamily;
        optFamilyLabelEl.textContent = isFamily ? "On" : "Off";

        // middleCount selector
        const cap = Math.min(3, availableMiddleGames.length);
        middleCapHintEl.textContent = `(available: ${availableMiddleGames.length}, max: ${cap})`;

        // clamp UI options list availability
        [...optMiddleCountEl.options].forEach((o) => {
          const v = Number(o.value);
          o.disabled = v > cap;
        });

        // ensure selected value is valid
        const current = Number(roomOptions.middleCount) || 0;
        const clamped = Math.max(0, Math.min(current, cap));
        optMiddleCountEl.value = String(clamped);
      }

      function requestOptionsUpdate(partial) {
        if (!currentRoomCode) return;
        if (gameStatus !== "lobby") return;

        socket.emit(
          "host:update_options",
          { roomCode: currentRoomCode, options: partial },
          (ack) => {
            if (!ack?.ok) {
              statusEl.textContent = `Options update failed: ${
                ack?.reason || "UNKNOWN"
              }`;
              // bounce UI back to last known server truth
              applyOptionsToUI();
              return;
            }
            statusEl.textContent = "Options saved.";
          }
        );
      }

      function kickPlayer(playerId, displayName) {
        if (!currentRoomCode) return;
        if (gameStatus !== "lobby") return;

        const ok = confirm(
          `Kick ${
            displayName || "this player"
          }? They won't be able to rejoin this room.`
        );
        if (!ok) return;

        socket.emit(
          "host:kick_player",
          { roomCode: currentRoomCode, playerId },
          (ack) => {
            if (!ack?.ok) {
              statusEl.textContent = `Kick failed: ${ack?.reason || "UNKNOWN"}`;
              return;
            }
            statusEl.textContent = `Kicked ${displayName || "player"}.`;
          }
        );
      }

      function resetUIToLobby() {
        currentRoomCode = null;
        roomCodeEl.textContent = "----";
        btnStart.disabled = true;
        btnEnd.disabled = true;

        pickEndsAt = null;
        questionEndsAt = null;
        r1QuestionTimerEl.textContent = "—";

        setStateLabel("LOBBY");
        setGameStatus("lobby");

        // default options
        roomOptions = {
          contentRating: "standard",
          middleCount: 0,
          selectedMiddleGames: null,
        };
        availableMiddleGames = [];
        applyOptionsToUI();

        resetFastestUI();
        lastResultEl.textContent = "(none)";
        renderPlayers([]);
        setR1Hud({});
        setPickUIInactive();
        statusEl.textContent = "";
      }

      // --------------------
      // Countdown render loop
      // --------------------
      function msLeft(endsAt) {
        if (!Number.isFinite(endsAt)) return null;
        return Math.max(0, endsAt - Date.now());
      }

      function fmtSeconds(ms) {
        const s = Math.ceil(ms / 1000);
        return `${s}s`;
      }

      function tickCountdowns() {
        if (pickActive && Number.isFinite(pickEndsAt)) {
          const left = msLeft(pickEndsAt);
          if (left == null) {
            r1PickStatusEl.textContent = pickStatusBaseText;
          } else if (left <= 0) {
            r1PickStatusEl.textContent = `${pickStatusBaseText} (auto-picking…)`;
          } else {
            r1PickStatusEl.textContent = `${pickStatusBaseText} (${fmtSeconds(
              left
            )})`;
          }
        } else {
          if (!pickActive) r1PickStatusEl.textContent = pickStatusBaseText;
        }

        if (Number.isFinite(questionEndsAt)) {
          const left = msLeft(questionEndsAt);
          if (left == null) {
            r1QuestionTimerEl.textContent = "—";
          } else if (left <= 0) {
            r1QuestionTimerEl.textContent = "0s";
          } else {
            r1QuestionTimerEl.textContent = fmtSeconds(left);
          }
        } else {
          r1QuestionTimerEl.textContent = "—";
        }
      }

      setInterval(tickCountdowns, 100);

      // --------------------
      // Refresh warning (kills game)
      // --------------------
      window.addEventListener("beforeunload", (e) => {
        if (currentRoomCode) {
          e.preventDefault();
          e.returnValue =
            "Refreshing or closing will end the current game for everyone.";
        }
      });

      // --------------------
      // Create Room
      // --------------------
      btnCreate.addEventListener("click", () => {
        statusEl.textContent = "Creating room...";
        resetFastestUI();
        lastResultEl.textContent = "(none)";
        btnStart.disabled = true;
        btnEnd.disabled = true;
        setR1Hud({});
        setPickUIInactive();

        pickEndsAt = null;
        questionEndsAt = null;

        socket.emit("host:create_room", { maxPlayers: 6 }, (ack) => {
          if (!ack?.ok) {
            statusEl.textContent = "Failed to create room.";
            return;
          }

          currentRoomCode = ack.roomCode;
          roomCodeEl.textContent = ack.roomCode;
          btnStart.disabled = false;
          btnEnd.disabled = false;

          setStateLabel("LOBBY");
          // gameStatus/options will come via server events; keep optimistic
          setGameStatus("lobby");
          statusEl.textContent = "Room created. Players can join now.";
          renderPlayers([]);
        });
      });

      // --------------------
      // Start Game
      // --------------------
      btnStart.addEventListener("click", () => {
        if (!currentRoomCode) return;

        statusEl.textContent = "Starting game...";
        socket.emit("host:start_game", { roomCode: currentRoomCode }, (ack) => {
          if (!ack?.ok) {
            statusEl.textContent = `Start failed: ${ack?.reason || "UNKNOWN"}`;
            return;
          }
          statusEl.textContent = "Game started.";
        });
      });

      // --------------------
      // End Game
      // --------------------
      btnEnd.addEventListener("click", () => {
        if (!currentRoomCode) return;

        const ok = confirm(
          "End the game for everyone? (Phones will be booted)"
        );
        if (!ok) return;

        statusEl.textContent = "Ending game...";
        socket.emit("host:end_game", { roomCode: currentRoomCode }, (ack) => {
          if (!ack?.ok) {
            statusEl.textContent = `End failed: ${ack?.reason || "UNKNOWN"}`;
            return;
          }
          statusEl.textContent = "Game ended.";
          resetUIToLobby();
        });
      });

      // --------------------
      // Options UI events
      // --------------------
      optFamilyEl.addEventListener("change", () => {
        const next = optFamilyEl.checked ? "family" : "standard";
        optFamilyLabelEl.textContent = optFamilyEl.checked ? "On" : "Off";
        requestOptionsUpdate({ contentRating: next });
      });

      optMiddleCountEl.addEventListener("change", () => {
        const v = Number(optMiddleCountEl.value);
        requestOptionsUpdate({ middleCount: v });
      });

      // --------------------
      // Server Events
      // --------------------
      socket.on("server:player_list_updated", ({ players }) => {
        renderPlayers(players);
      });

      // NEW: options snapshot (authoritative)
      socket.on("server:options_updated", (payload = {}) => {
        if (
          payload.roomCode &&
          currentRoomCode &&
          payload.roomCode !== currentRoomCode
        )
          return;

        if (payload.gameStatus) setGameStatus(payload.gameStatus);

        if (payload.options) roomOptions = payload.options;
        if (Array.isArray(payload.availableMiddleGames))
          availableMiddleGames = payload.availableMiddleGames;

        applyOptionsToUI();
      });

      socket.on(
        "server:state_changed",
        ({ state, r1, gameStatus: gs, options } = {}) => {
          setStateLabel(state);

          // Keep gameStatus/options in sync if server includes them here too
          if (gs) setGameStatus(gs);
          if (options) {
            roomOptions = options;
            applyOptionsToUI();
          }

          if (r1) {
            setR1Hud({
              blockIndex: r1.blockIndex,
              totalBlocks: 4,
              categoryId: r1.currentCategoryId,
              categoryName: r1.currentCategoryName,
              chooserDisplayName: r1.chooserDisplayName,
            });

            if (Number.isFinite(r1.pickEndsAt)) pickEndsAt = r1.pickEndsAt;
            else if (r1.pickEndsAt === null) pickEndsAt = null;

            if (Number.isFinite(r1.questionEndsAt))
              questionEndsAt = r1.questionEndsAt;
            else if (r1.questionEndsAt === null) questionEndsAt = null;
          }

          if (state === "ROUND_1_CATEGORY_PICK" && r1) {
            setPickUIActive({
              chooserDisplayName: r1.chooserDisplayName,
              options: r1.pickOptionsDetailed || [],
            });
          } else {
            setPickUIInactive();
          }
        }
      );

      socket.on("server:r1_fastest_state", (payload) => {
        setFastestStatus(payload);
        if (Number.isFinite(payload?.endsAt)) questionEndsAt = payload.endsAt;
        else if (payload?.endsAt === null) questionEndsAt = null;
      });

      socket.on("server:r1_question_presented", ({ prompt, endsAt }) => {
        lastResultEl.textContent = `Q: ${prompt}`;
        if (Number.isFinite(endsAt)) questionEndsAt = endsAt;
      });

      socket.on(
        "server:r1_answer_locked_out",
        ({ answeringDisplayName, answeringPlayerId, chosen, scoreDelta }) => {
          const who = answeringDisplayName || answeringPlayerId || "Someone";
          lastResultEl.textContent = `${who} LOCKED OUT (${scoreDelta}) — chose ${chosen}`;
        }
      );

      socket.on(
        "server:r1_answer_winner",
        ({ winnerDisplayName, winnerPlayerId, chosen, scoreDelta }) => {
          const who = winnerDisplayName || winnerPlayerId || "Someone";
          lastResultEl.textContent = `${who} WINS (${scoreDelta}) — chose ${chosen}`;
          questionEndsAt = null;
        }
      );

      socket.on(
        "server:r1_answer_timeout",
        ({ correctChoice, scoreDeltaIfNoAttempt }) => {
          lastResultEl.textContent = `TIMEOUT — correct was ${correctChoice} (no-attempt penalty ${scoreDeltaIfNoAttempt})`;
          questionEndsAt = null;
        }
      );

      socket.on("server:error", (err) => {
        statusEl.textContent = `Error: ${err?.code || "UNKNOWN"}`;
        if (err?.code === "ROOM_CLOSED") {
          resetUIToLobby();
        }
      });

      // Initial render
      resetUIToLobby();
    </script>
  </body>
</html>
