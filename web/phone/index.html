<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Phone</title>
    <style>
      body {
        font-family: system-ui, Arial, sans-serif;
        margin: 24px;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 16px;
        max-width: 420px;
      }
      input {
        width: 100%;
        padding: 10px;
        margin: 8px 0;
        box-sizing: border-box;
      }
      button {
        padding: 14px;
        cursor: pointer;
        width: 100%;
        font-size: 18px;
      }
      .muted {
        color: #666;
      }
      .hidden {
        display: none;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .choice {
        font-size: 18px;
        font-weight: 800;
        padding: 16px;
        line-height: 1.15;
        min-height: 86px;
        white-space: normal;
        text-align: left;
      }
      .choice .letter {
        display: inline-block;
        font-weight: 900;
        margin-right: 8px;
      }
      .msg {
        margin-top: 10px;
      }
      .stack {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 12px;
      }
      .small {
        font-size: 13px;
      }
      #questionText {
        white-space: pre-wrap;
      }
      /* NEW */
      .timer {
        font-weight: 900;
        letter-spacing: 0.3px;
      }
    </style>
  </head>
  <body>
    <h1>Join Game</h1>

    <!-- JOIN -->
    <div id="joinCard" class="card">
      <label class="muted">Game Code</label>
      <input id="roomCode" placeholder="ABCD" maxlength="4" />

      <label class="muted">Name</label>
      <input id="displayName" placeholder="Your name" maxlength="16" />

      <button id="btnJoin">Join</button>
      <div id="error" class="muted msg"></div>
    </div>

    <!-- WAITING -->
    <div id="waitingCard" class="card hidden">
      <div class="muted">Joined</div>
      <h2 id="joinedLabel">Waiting…</h2>
      <div class="muted">Keep this screen open.</div>
      <div class="muted msg">State: <span id="stateLabel">LOBBY</span></div>
    </div>

    <!-- CATEGORY PICK -->
    <div id="pickCard" class="card hidden">
      <div class="muted">Round 1</div>
      <h2>Pick the next category</h2>
      <div id="pickHelp" class="muted msg"></div>

      <div id="pickOptions" class="stack"></div>

      <div id="pickMsg" class="muted msg small"></div>
      <!-- NEW: live countdown -->
      <div id="pickCountdown" class="muted msg small timer"></div>
    </div>

    <!-- FASTEST (everyone answers) -->
    <div id="fastestCard" class="card hidden">
      <div class="muted">Round 1</div>
      <h2 id="fastestHeader">FASTEST FINGER</h2>
      <!-- NEW: live countdown -->
      <div id="fastestCountdown" class="muted msg small timer"></div>

      <div id="questionText" class="muted msg"></div>

      <div class="grid msg">
        <button class="choice" data-choice="A">
          <span class="letter">A</span><span class="txt" data-txt="A">—</span>
        </button>
        <button class="choice" data-choice="B">
          <span class="letter">B</span><span class="txt" data-txt="B">—</span>
        </button>
        <button class="choice" data-choice="C">
          <span class="letter">C</span><span class="txt" data-txt="C">—</span>
        </button>
        <button class="choice" data-choice="D">
          <span class="letter">D</span><span class="txt" data-txt="D">—</span>
        </button>
      </div>

      <div id="fastestMsg" class="muted msg"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      // ---- localStorage keys (Jackbox-style persistence)
      const LS_ROOM = "gsp_roomCode";
      const LS_NAME = "gsp_displayName";
      const LS_TOKEN = "gsp_playerToken";

      const joinCard = document.getElementById("joinCard");
      const waitingCard = document.getElementById("waitingCard");
      const pickCard = document.getElementById("pickCard");
      const fastestCard = document.getElementById("fastestCard");

      const roomCodeInput = document.getElementById("roomCode");
      const nameInput = document.getElementById("displayName");
      const btnJoin = document.getElementById("btnJoin");

      const errorEl = document.getElementById("error");
      const joinedLabel = document.getElementById("joinedLabel");
      const stateLabelEl = document.getElementById("stateLabel");

      const pickHelp = document.getElementById("pickHelp");
      const pickOptionsEl = document.getElementById("pickOptions");
      const pickMsg = document.getElementById("pickMsg");

      const fastestHeader = document.getElementById("fastestHeader");
      const questionText = document.getElementById("questionText");
      const fastestMsg = document.getElementById("fastestMsg");

      // NEW: countdown els
      const pickCountdownEl = document.getElementById("pickCountdown");
      const fastestCountdownEl = document.getElementById("fastestCountdown");

      let myRoomCode = null;
      let myPlayerId = null;
      let myPlayerToken = null;
      let myAvatarId = null;

      // current question cache (from server:r1_question_presented)
      let currentQuestion = null; // { questionId, prompt, answers }

      // fastest snapshot cache (from server:r1_fastest_state)
      let fastestState = null; // { isOpen, winner, lockedOutPlayerIds, answeredPlayerIds, questionId }

      // category pick cache
      let currentPick = null; // { chooserPlayerId, chooserDisplayName, options: [{id,name}], timeoutMs, endsAt? }
      let pickLocked = false;

      // NEW: deadline-based countdowns (epoch ms)
      let pickEndsAt = null;
      let questionEndsAt = null;

      function setStateLabel(state) {
        stateLabelEl.textContent = state || "UNKNOWN";
      }

      function showOnly(el) {
        [joinCard, waitingCard, pickCard, fastestCard].forEach((c) =>
          c.classList.add("hidden")
        );
        el.classList.remove("hidden");
      }

      function setChoiceButtonsEnabled(enabled) {
        document.querySelectorAll(".choice").forEach((btn) => {
          btn.disabled = !enabled;
        });
      }

      function saveSession(roomCode, displayName, playerToken) {
        localStorage.setItem(LS_ROOM, roomCode);
        localStorage.setItem(LS_NAME, displayName);
        localStorage.setItem(LS_TOKEN, playerToken);
      }

      function clearPickUI() {
        pickOptionsEl.innerHTML = "";
        pickHelp.textContent = "";
        pickMsg.textContent = "";
        pickCountdownEl.textContent = "";
        pickLocked = false;
      }

      function clearSession() {
        localStorage.removeItem(LS_ROOM);
        localStorage.removeItem(LS_NAME);
        localStorage.removeItem(LS_TOKEN);

        myRoomCode = null;
        myPlayerId = null;
        myPlayerToken = null;
        myAvatarId = null;

        currentQuestion = null;
        fastestState = null;

        currentPick = null;
        pickLocked = false;
        clearPickUI();

        pickEndsAt = null;
        questionEndsAt = null;
        fastestCountdownEl.textContent = "";
      }

      function normalizeOptions(arr) {
        // Accept either [{id,name}] or ["id","id2"]
        if (!Array.isArray(arr)) return [];
        if (arr.length === 0) return [];
        if (typeof arr[0] === "string")
          return arr.map((id) => ({ id, name: id }));
        return arr
          .map((o) => ({
            id: o?.id ?? "",
            name: o?.name ?? o?.id ?? "",
          }))
          .filter((o) => o.id);
      }

      // NEW: countdown helpers
      function msLeft(endsAt) {
        if (!Number.isFinite(endsAt)) return null;
        return Math.max(0, endsAt - Date.now());
      }
      function fmtSeconds(ms) {
        return `${Math.ceil(ms / 1000)}s`;
      }

      function tickCountdowns() {
        // Category pick countdown (only show while pick card is visible)
        if (
          !pickCard.classList.contains("hidden") &&
          Number.isFinite(pickEndsAt)
        ) {
          const left = msLeft(pickEndsAt);
          if (left == null) pickCountdownEl.textContent = "";
          else if (left <= 0) pickCountdownEl.textContent = "Auto-picking…";
          else pickCountdownEl.textContent = `Time left: ${fmtSeconds(left)}`;
        } else {
          pickCountdownEl.textContent = "";
        }

        // Question countdown (only show while fastest card is visible)
        if (
          !fastestCard.classList.contains("hidden") &&
          Number.isFinite(questionEndsAt)
        ) {
          const left = msLeft(questionEndsAt);
          if (left == null) fastestCountdownEl.textContent = "";
          else if (left <= 0) fastestCountdownEl.textContent = "Time: 0s";
          else fastestCountdownEl.textContent = `Time: ${fmtSeconds(left)}`;
        } else {
          fastestCountdownEl.textContent = "";
        }
      }

      setInterval(tickCountdowns, 100);

      function renderPickUI() {
        clearPickUI();
        if (!currentPick) return;

        const chooserId = currentPick.chooserPlayerId;
        const isChooser = !!(
          myPlayerId &&
          chooserId &&
          myPlayerId === chooserId
        );

        if (isChooser) {
          pickHelp.textContent =
            "You're in last place — choose the next category:";
        } else {
          const who = currentPick.chooserDisplayName
            ? currentPick.chooserDisplayName
            : "the chooser";
          pickHelp.textContent = `Waiting for ${who} to pick the next category…`;
        }

        const options = normalizeOptions(currentPick.options);

        options.forEach((opt) => {
          const btn = document.createElement("button");
          btn.textContent = opt.name || opt.id;
          btn.disabled = !isChooser || pickLocked;

          btn.addEventListener("click", () => {
            if (!isChooser || pickLocked) return;
            pickLocked = true;

            pickMsg.textContent = "Sending pick…";
            pickOptionsEl
              .querySelectorAll("button")
              .forEach((b) => (b.disabled = true));

            socket.emit(
              "phone:r1_pick_category",
              {
                roomCode: myRoomCode,
                playerId: myPlayerId,
                categoryId: opt.id,
              },
              (ack) => {
                if (!ack?.ok) {
                  pickLocked = false;
                  pickMsg.textContent = `Nope: ${ack?.reason || "UNKNOWN"}`;
                  pickOptionsEl
                    .querySelectorAll("button")
                    .forEach((b) => (b.disabled = false));
                  return;
                }
                pickMsg.textContent = "Picked! Loading next block…";
              }
            );
          });

          pickOptionsEl.appendChild(btn);
        });

        // If server provides endsAt, prefer it. Else derive from timeoutMs.
        if (Number.isFinite(currentPick.endsAt)) {
          pickEndsAt = currentPick.endsAt;
        } else {
          const t = Number(currentPick.timeoutMs);
          pickEndsAt = Number.isFinite(t) && t > 0 ? Date.now() + t : null;
        }

        if (
          Number.isFinite(currentPick.timeoutMs) &&
          currentPick.timeoutMs > 0
        ) {
          pickMsg.textContent = "Choose quickly (auto-pick when timer hits 0).";
        }
      }

      function renderAnswerButtonsFromQuestion(q) {
        const letters = ["A", "B", "C", "D"];
        let answers = [];

        if (Array.isArray(q?.answers)) {
          answers = q.answers;
        } else if (q?.answers && typeof q.answers === "object") {
          answers = [
            q.answers.A ?? q.answers.a,
            q.answers.B ?? q.answers.b,
            q.answers.C ?? q.answers.c,
            q.answers.D ?? q.answers.d,
          ];
        }

        letters.forEach((L, i) => {
          const span = document.querySelector(`[data-txt="${L}"]`);
          if (!span) return;
          span.textContent =
            answers[i] != null && answers[i] !== "" ? String(answers[i]) : "—";
        });
      }

      function formatPromptOnly(q) {
        return q?.prompt ? String(q.prompt) : "(question loading…)";
      }

      function isMeLockedOut() {
        if (!fastestState || !myPlayerId) return false;
        const arr = fastestState.lockedOutPlayerIds || [];
        return arr.includes(myPlayerId);
      }

      function hasWinner() {
        return !!(fastestState && fastestState.winner);
      }

      function syncFastestUI() {
        if (fastestCard.classList.contains("hidden")) return;

        if (currentQuestion) {
          questionText.textContent = formatPromptOnly(currentQuestion);
          renderAnswerButtonsFromQuestion(currentQuestion);
        } else {
          questionText.textContent = "(question loading…)";
        }

        if (!fastestState) {
          fastestHeader.textContent = "FASTEST FINGER";
          fastestMsg.textContent = "";
          setChoiceButtonsEnabled(true);
          return;
        }

        if (fastestState.winner) {
          const w = fastestState.winner;
          fastestHeader.textContent = "CLOSED";
          fastestMsg.textContent = `Winner: ${w.displayName || w.playerId} (${
            w.choice || "?"
          })`;
          setChoiceButtonsEnabled(false);
          return;
        }

        if (!fastestState.isOpen) {
          fastestHeader.textContent = "CLOSED";
          fastestMsg.textContent = "";
          setChoiceButtonsEnabled(false);
          return;
        }

        fastestHeader.textContent = "FASTEST FINGER";
        if (isMeLockedOut()) {
          fastestMsg.textContent = "Locked out (wrong answer).";
          setChoiceButtonsEnabled(false);
        } else {
          fastestMsg.textContent = "Tap A / B / C / D — first correct wins.";
          setChoiceButtonsEnabled(true);
        }
      }

      // --------------------
      // Join (first time)
      // --------------------
      btnJoin.addEventListener("click", () => {
        errorEl.textContent = "";

        const roomCode = roomCodeInput.value.trim().toUpperCase();
        const displayName = nameInput.value.trim();

        socket.emit("phone:join_room", { roomCode, displayName }, (ack) => {
          if (!ack?.ok) {
            errorEl.textContent = `Join failed: ${ack?.reason || "UNKNOWN"}`;
            return;
          }

          myRoomCode = ack.roomCode;
          myPlayerId = ack.playerId;
          myPlayerToken = ack.playerToken;
          myAvatarId = ack.avatarId ?? null;

          saveSession(ack.roomCode, ack.displayName, ack.playerToken);

          showOnly(waitingCard);
          joinedLabel.textContent = `Room ${ack.roomCode} • Hi ${
            ack.displayName
          }!${myAvatarId ? " [" + myAvatarId + "]" : ""}`;
          setStateLabel(ack.state || "LOBBY");
        });
      });

      // --------------------
      // Auto-rejoin on refresh
      // --------------------
      function tryAutoRejoin() {
        const savedRoom = localStorage.getItem(LS_ROOM);
        const savedName = localStorage.getItem(LS_NAME);
        const savedToken = localStorage.getItem(LS_TOKEN);

        if (!savedRoom || !savedToken) return;

        roomCodeInput.value = savedRoom;
        if (savedName) nameInput.value = savedName;

        errorEl.textContent = "Rejoining game…";
        showOnly(joinCard);

        socket.emit(
          "phone:rejoin_room",
          { roomCode: savedRoom, playerToken: savedToken },
          (ack) => {
            if (!ack?.ok) {
              clearSession();
              errorEl.textContent =
                "Could not rejoin (game ended or token invalid). Please join again.";
              showOnly(joinCard);
              return;
            }

            myRoomCode = ack.roomCode;
            myPlayerId = ack.playerId;
            myPlayerToken = ack.playerToken;
            myAvatarId = ack.avatarId ?? null;

            saveSession(ack.roomCode, ack.displayName, ack.playerToken);

            showOnly(waitingCard);
            joinedLabel.textContent = `Room ${ack.roomCode} • Hi ${
              ack.displayName
            }!${myAvatarId ? " [" + myAvatarId + "]" : ""}`;
            setStateLabel(ack.state || "UNKNOWN");

            if (ack.state === "ROUND_1_CATEGORY_PICK") {
              showOnly(pickCard);
            } else if (ack.state === "ROUND_1_QUESTION_OPEN") {
              showOnly(fastestCard);
              syncFastestUI();
            } else if (ack.state === "ROUND_1_INTRO") {
              joinedLabel.textContent = "Round 1 starting…";
            }
          }
        );
      }

      // --------------------
      // Question presented (prompt + answers)
      // --------------------
      socket.on("server:r1_question_presented", (payload) => {
        const { questionId, prompt, answers } = payload || {};
        currentQuestion = { questionId, prompt, answers };

        showOnly(fastestCard);

        // If server provides endsAt, use it; else leave questionEndsAt alone (state may bring it)
        if (Number.isFinite(payload?.endsAt)) questionEndsAt = payload.endsAt;

        if (!fastestState || fastestState.questionId !== questionId) {
          fastestState = {
            questionId,
            isOpen: true,
            winner: null,
            lockedOutPlayerIds: [],
            answeredPlayerIds: [],
          };
        }

        questionText.textContent = formatPromptOnly(currentQuestion);
        renderAnswerButtonsFromQuestion(currentQuestion);
        syncFastestUI();
      });

      // --------------------
      // Fastest snapshot state (winner / locked out list)
      // --------------------
      socket.on("server:r1_fastest_state", (payload) => {
        fastestState = payload || null;

        if (payload?.isOpen) showOnly(fastestCard);

        // If server provides endsAt, use it
        if (Number.isFinite(payload?.endsAt)) questionEndsAt = payload.endsAt;
        else if (payload?.endsAt === null) questionEndsAt = null;

        syncFastestUI();
      });

      // --------------------
      // Category pick event
      // --------------------
      socket.on("server:r1_category_pick", (payload) => {
        currentPick = {
          chooserPlayerId: payload?.chooserPlayerId ?? null,
          chooserDisplayName: payload?.chooserDisplayName ?? null,
          options: payload?.options || [],
          timeoutMs: payload?.timeoutMs || null,
          endsAt: payload?.endsAt ?? null, // NEW (optional)
        };

        showOnly(pickCard);
        renderPickUI();
      });

      // --------------------
      // State changes
      // --------------------
      socket.on("server:state_changed", ({ state, r1 } = {}) => {
        setStateLabel(state);

        const hasSession = !!(myRoomCode || localStorage.getItem(LS_ROOM));
        if (!hasSession) return;

        // NEW: accept deadlines from state snapshot if you include them server-side
        if (r1) {
          if (Number.isFinite(r1.pickEndsAt)) pickEndsAt = r1.pickEndsAt;
          else if (r1.pickEndsAt === null) pickEndsAt = null;

          if (Number.isFinite(r1.questionEndsAt))
            questionEndsAt = r1.questionEndsAt;
          else if (r1.questionEndsAt === null) questionEndsAt = null;
        }

        if (state === "ROUND_1_CATEGORY_PICK") {
          const detailed = r1?.pickOptionsDetailed;
          const fallback = r1?.pickOptions;

          currentPick = {
            chooserPlayerId: r1?.chooserPlayerId ?? null,
            chooserDisplayName: r1?.chooserDisplayName ?? null,
            options: detailed && detailed.length ? detailed : fallback || [],
            timeoutMs: currentPick?.timeoutMs || null,
            endsAt: Number.isFinite(r1?.pickEndsAt)
              ? r1.pickEndsAt
              : currentPick?.endsAt ?? null,
          };

          showOnly(pickCard);
          renderPickUI();
          return;
        }

        if (state === "ROUND_1_QUESTION_OPEN") {
          showOnly(fastestCard);

          // Fallback: if server doesn't send endsAt yet, and we have a question,
          // derive from the question's timeLimit if you decide to include it later.
          // (Best solution: server sends endsAt.)
          syncFastestUI();
          return;
        }

        // leaving pick/question screens
        currentPick = null;
        clearPickUI();
        pickEndsAt = null;
        questionEndsAt = null;

        if (state === "ROUND_1_INTRO") {
          showOnly(waitingCard);
          joinedLabel.textContent = "Round 1 starting…";
          return;
        }
        if (state === "ROUND_1_COMPLETE") {
          showOnly(waitingCard);
          joinedLabel.textContent = "Round 1 complete!";
          return;
        }

        showOnly(waitingCard);
      });

      // --------------------
      // Wrong tap -> locked out
      // --------------------
      socket.on(
        "server:r1_answer_locked_out",
        ({ questionId, answeringPlayerId, chosen, scoreDelta }) => {
          if (!myPlayerId) return;
          if (answeringPlayerId !== myPlayerId) return;

          if (
            questionId &&
            currentQuestion?.questionId &&
            questionId !== currentQuestion.questionId
          )
            return;

          fastestMsg.textContent = `Wrong (${scoreDelta}). Locked out. You chose ${chosen}.`;
          setChoiceButtonsEnabled(false);
        }
      );

      // --------------------
      // Winner declared
      // --------------------
      socket.on(
        "server:r1_answer_winner",
        ({
          questionId,
          winnerPlayerId,
          winnerDisplayName,
          chosen,
          scoreDelta,
        }) => {
          if (
            questionId &&
            currentQuestion?.questionId &&
            questionId !== currentQuestion.questionId
          )
            return;

          showOnly(fastestCard);
          fastestHeader.textContent = "CLOSED";

          const who = winnerDisplayName || winnerPlayerId || "Someone";
          fastestMsg.textContent = `Winner: ${who} (${chosen}) (+${scoreDelta})`;
          setChoiceButtonsEnabled(false);

          questionEndsAt = null;
        }
      );

      // --------------------
      // Timeout (no winner)
      // --------------------
      socket.on(
        "server:r1_answer_timeout",
        ({ questionId, correctChoice, scoreDeltaIfNoAttempt }) => {
          if (
            questionId &&
            currentQuestion?.questionId &&
            questionId !== currentQuestion.questionId
          )
            return;

          showOnly(fastestCard);
          fastestHeader.textContent = "TIME";
          fastestMsg.textContent = `Time! Correct was ${correctChoice}. (No-attempt penalty ${scoreDeltaIfNoAttempt})`;
          setChoiceButtonsEnabled(false);

          questionEndsAt = null;
        }
      );

      // --------------------
      // Tapping an answer (Option 2)
      // --------------------
      document.querySelectorAll(".choice").forEach((btn) => {
        btn.addEventListener("click", () => {
          const choice = btn.getAttribute("data-choice");
          if (!choice) return;

          if (hasWinner()) return;
          if (isMeLockedOut()) return;

          setChoiceButtonsEnabled(false);
          fastestMsg.textContent = "Sent…";

          socket.emit(
            "phone:r1_answer_tap",
            { roomCode: myRoomCode, playerId: myPlayerId, choice },
            (ack) => {
              if (!ack?.ok) {
                fastestMsg.textContent = `Nope: ${ack?.reason || "UNKNOWN"}`;

                if (
                  ack?.reason === "LOCKED_OUT" ||
                  ack?.reason === "ALREADY_HAS_WINNER" ||
                  ack?.reason === "QUESTION_NOT_OPEN"
                ) {
                  setChoiceButtonsEnabled(false);
                } else {
                  setChoiceButtonsEnabled(true);
                }
              }
            }
          );
        });
      });

      // --------------------
      // Room closed
      // --------------------
      socket.on("server:error", (err) => {
        if (err?.code === "ROOM_CLOSED") {
          clearSession();
          errorEl.textContent = "Host ended the game.";
          showOnly(joinCard);
          return;
        }

        errorEl.textContent = `Error: ${err?.code || "UNKNOWN"}`;
      });

      // Kick off
      setStateLabel("LOBBY");
      tryAutoRejoin();
    </script>
  </body>
</html>
