<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Phone</title>
    <style>
      body {
        font-family: system-ui, Arial, sans-serif;
        margin: 24px;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 16px;
        max-width: 420px;
      }
      input {
        width: 100%;
        padding: 10px;
        margin: 8px 0;
        box-sizing: border-box;
      }
      button {
        padding: 14px;
        cursor: pointer;
        width: 100%;
        font-size: 18px;
      }
      .muted {
        color: #666;
      }
      .hidden {
        display: none;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .choice,
      .finalChoice {
        font-size: 18px;
        font-weight: 800;
        padding: 16px;
        line-height: 1.15;
        min-height: 86px;
        white-space: normal;
        text-align: left;
      }
      .choice .letter,
      .finalChoice .letter {
        display: inline-block;
        font-weight: 900;
        margin-right: 8px;
      }
      .msg {
        margin-top: 10px;
      }
      .stack {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 12px;
      }
      .small {
        font-size: 13px;
      }
      #questionText,
      #finalQuestionText {
        white-space: pre-wrap;
      }
      .timer {
        font-weight: 900;
        letter-spacing: 0.3px;
      }

      /* options pill */
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 12px;
        color: #444;
        margin-left: 6px;
      }

      /* FINAL: podium bar */
      .podiumRow {
        margin-top: 10px;
      }
      .podiumLabel {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
      }
      .barWrap {
        width: 100%;
        height: 16px;
        border: 1px solid #ddd;
        border-radius: 999px;
        overflow: hidden;
        margin-top: 6px;
        background: #fafafa;
      }
      .barFill {
        height: 100%;
        width: 0%;
        background: #222;
        transition: width 80ms linear;
      }
    </style>
  </head>
  <body>
    <h1>Join Game</h1>

    <!-- JOIN -->
    <div id="joinCard" class="card">
      <label class="muted">Game Code</label>
      <input id="roomCode" placeholder="ABCD" maxlength="4" />

      <label class="muted">Name</label>
      <input id="displayName" placeholder="Your name" maxlength="16" />

      <button id="btnJoin">Join</button>
      <div id="error" class="muted msg"></div>
    </div>

    <!-- WAITING -->
    <div id="waitingCard" class="card hidden">
      <div class="muted">Joined</div>
      <h2 id="joinedLabel">Waiting‚Ä¶</h2>
      <div class="muted">Keep this screen open.</div>
      <div class="muted msg">
        State: <span id="stateLabel">LOBBY</span>
        <span id="familyPill" class="pill">standard</span>
      </div>
    </div>

    <!-- CATEGORY PICK -->
    <div id="pickCard" class="card hidden">
      <div class="muted">Round 1</div>
      <h2>Pick the next category</h2>
      <div id="pickHelp" class="muted msg"></div>

      <div id="pickOptions" class="stack"></div>

      <div id="pickMsg" class="muted msg small"></div>
      <div id="pickCountdown" class="muted msg small timer"></div>
    </div>

    <!-- FASTEST (everyone answers) -->
    <div id="fastestCard" class="card hidden">
      <div class="muted">Round 1</div>
      <h2 id="fastestHeader">FASTEST FINGER</h2>
      <div id="fastestCountdown" class="muted msg small timer"></div>

      <div id="questionText" class="muted msg"></div>

      <div class="grid msg">
        <button class="choice" data-choice="A">
          <span class="letter">A</span><span class="txt" data-txt="A">‚Äî</span>
        </button>
        <button class="choice" data-choice="B">
          <span class="letter">B</span><span class="txt" data-txt="B">‚Äî</span>
        </button>
        <button class="choice" data-choice="C">
          <span class="letter">C</span><span class="txt" data-txt="C">‚Äî</span>
        </button>
        <button class="choice" data-choice="D">
          <span class="letter">D</span><span class="txt" data-txt="D">‚Äî</span>
        </button>
      </div>

      <div id="fastestMsg" class="muted msg"></div>
    </div>

    <!-- FINAL PODIUM -->
    <div id="finalCard" class="card hidden">
      <div class="muted">Final Round</div>
      <h2 id="finalHeader">FINAL PODIUM</h2>
      <div id="finalCountdown" class="muted msg small timer"></div>

      <div class="podiumRow">
        <div class="podiumLabel muted small">
          <span>Your podium</span>
          <span id="podiumPct">0%</span>
        </div>
        <div class="barWrap">
          <div id="podiumFill" class="barFill"></div>
        </div>
      </div>

      <div id="finalQuestionText" class="muted msg"></div>

      <div class="grid msg">
        <button class="finalChoice" data-choice="A">
          <span class="letter">A</span><span class="txt" data-txt="A">‚Äî</span>
        </button>
        <button class="finalChoice" data-choice="B">
          <span class="letter">B</span><span class="txt" data-txt="B">‚Äî</span>
        </button>
        <button class="finalChoice" data-choice="C">
          <span class="letter">C</span><span class="txt" data-txt="C">‚Äî</span>
        </button>
        <button class="finalChoice" data-choice="D">
          <span class="letter">D</span><span class="txt" data-txt="D">‚Äî</span>
        </button>
      </div>

      <div id="finalMsg" class="muted msg"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      // ---- localStorage keys (Jackbox-style persistence)
      const LS_ROOM = "gsp_roomCode";
      const LS_NAME = "gsp_displayName";
      const LS_TOKEN = "gsp_playerToken";

      // FINAL fall rate (client-side visual approximation)
      // Keep this in sync with server FINAL_FALL_RATE_PER_SEC.
      const FINAL_FALL_RATE_PER_SEC = 0.1;

      const joinCard = document.getElementById("joinCard");
      const waitingCard = document.getElementById("waitingCard");
      const pickCard = document.getElementById("pickCard");
      const fastestCard = document.getElementById("fastestCard");
      const finalCard = document.getElementById("finalCard");

      const roomCodeInput = document.getElementById("roomCode");
      const nameInput = document.getElementById("displayName");
      const btnJoin = document.getElementById("btnJoin");

      const errorEl = document.getElementById("error");
      const joinedLabel = document.getElementById("joinedLabel");
      const stateLabelEl = document.getElementById("stateLabel");
      const familyPillEl = document.getElementById("familyPill");

      const pickHelp = document.getElementById("pickHelp");
      const pickOptionsEl = document.getElementById("pickOptions");
      const pickMsg = document.getElementById("pickMsg");
      const pickCountdownEl = document.getElementById("pickCountdown");

      const fastestHeader = document.getElementById("fastestHeader");
      const questionText = document.getElementById("questionText");
      const fastestMsg = document.getElementById("fastestMsg");
      const fastestCountdownEl = document.getElementById("fastestCountdown");

      const finalHeader = document.getElementById("finalHeader");
      const finalQuestionText = document.getElementById("finalQuestionText");
      const finalMsg = document.getElementById("finalMsg");
      const finalCountdownEl = document.getElementById("finalCountdown");

      const podiumFill = document.getElementById("podiumFill");
      const podiumPct = document.getElementById("podiumPct");

      let myRoomCode = null;
      let myPlayerId = null;
      let myPlayerToken = null;
      let myAvatarId = null;

      // options snapshot
      let roomOptions = {
        contentRating: "standard",
        middleCount: 0,
        selectedMiddleGames: null,
      };

      // Round 1 question cache
      let currentQuestion = null; // { questionId, prompt, answers }
      let fastestState = null; // { isOpen, winner, lockedOutPlayerIds, answeredPlayerIds, questionId }

      // category pick cache
      let currentPick = null; // { chooserPlayerId, chooserDisplayName, options: [{id,name}], timeoutMs, endsAt? }
      let pickLocked = false;

      // Final round cache
      let finalQuestion = null; // { questionId, prompt, answers }
      let finalLocked = false; // did I submit an answer for this question?
      let finalEndsAt = null;

      // Final: live bar state
      let finalHeights = {}; // pid -> 0..1
      let finalAliveIds = [];
      let finalPhase = null;

      // For client-side falling: capture my height at "start" and count down
      let myFinalHeightBase = null; // number 0..1
      let myFinalHeightBaseAt = null; // epoch ms

      // deadline-based countdowns (epoch ms)
      let pickEndsAt = null;
      let questionEndsAt = null;

      function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function setStateLabel(state) {
        stateLabelEl.textContent = state || "UNKNOWN";
      }

      function applyOptionsToUI() {
        const rating = roomOptions?.contentRating || "standard";
        familyPillEl.textContent = rating;
      }

      function showOnly(el) {
        [joinCard, waitingCard, pickCard, fastestCard, finalCard].forEach((c) =>
          c.classList.add("hidden")
        );
        el.classList.remove("hidden");
      }

      function setChoiceButtonsEnabled(enabled) {
        fastestCard.querySelectorAll(".choice").forEach((btn) => {
          btn.disabled = !enabled;
        });
      }

      function setFinalButtonsEnabled(enabled) {
        finalCard.querySelectorAll(".finalChoice").forEach((btn) => {
          btn.disabled = !enabled;
        });
      }

      function saveSession(roomCode, displayName, playerToken) {
        localStorage.setItem(LS_ROOM, roomCode);
        localStorage.setItem(LS_NAME, displayName);
        localStorage.setItem(LS_TOKEN, playerToken);
      }

      function clearPickUI() {
        pickOptionsEl.innerHTML = "";
        pickHelp.textContent = "";
        pickMsg.textContent = "";
        pickCountdownEl.textContent = "";
        pickLocked = false;
      }

      function clearSession() {
        localStorage.removeItem(LS_ROOM);
        localStorage.removeItem(LS_NAME);
        localStorage.removeItem(LS_TOKEN);

        myRoomCode = null;
        myPlayerId = null;
        myPlayerToken = null;
        myAvatarId = null;

        roomOptions = {
          contentRating: "standard",
          middleCount: 0,
          selectedMiddleGames: null,
        };
        applyOptionsToUI();

        currentQuestion = null;
        fastestState = null;

        currentPick = null;
        pickLocked = false;
        clearPickUI();

        finalQuestion = null;
        finalLocked = false;
        finalEndsAt = null;

        finalHeights = {};
        finalAliveIds = [];
        finalPhase = null;

        myFinalHeightBase = null;
        myFinalHeightBaseAt = null;
        setPodiumUI(0);

        finalHeader.textContent = "FINAL PODIUM";
        finalMsg.textContent = "";
        finalQuestionText.textContent = "";

        pickEndsAt = null;
        questionEndsAt = null;
        fastestCountdownEl.textContent = "";
      }

      function normalizeOptions(arr) {
        // Accept either [{id,name}] or ["id","id2"]
        if (!Array.isArray(arr)) return [];
        if (arr.length === 0) return [];
        if (typeof arr[0] === "string")
          return arr.map((id) => ({ id, name: id }));
        return arr
          .map((o) => ({
            id: o?.id ?? "",
            name: o?.name ?? o?.id ?? "",
          }))
          .filter((o) => o.id);
      }

      // countdown helpers
      function msLeft(endsAt) {
        if (!Number.isFinite(endsAt)) return null;
        return Math.max(0, endsAt - Date.now());
      }
      function fmtSeconds(ms) {
        return `${Math.ceil(ms / 1000)}s`;
      }

      function setPodiumUI(height01) {
        const h = clamp(Number(height01) || 0, 0, 1);
        const pct = Math.round(h * 100);
        podiumFill.style.width = `${pct}%`;
        podiumPct.textContent = `${pct}%`;
      }

      function computeMyLiveFinalHeight() {
        // If we don't have base, fall back to snapshot
        if (
          !Number.isFinite(myFinalHeightBase) ||
          !Number.isFinite(myFinalHeightBaseAt)
        ) {
          const snap = finalHeights?.[myPlayerId];
          return Number.isFinite(snap) ? snap : 0;
        }

        // Only ‚Äúfall‚Äù during open question, while alive, and if I haven‚Äôt answered
        const isAlive =
          myPlayerId &&
          Array.isArray(finalAliveIds) &&
          finalAliveIds.includes(myPlayerId);
        const shouldFall =
          (finalPhase === "question_open" ||
            finalPhase === "FINAL_QUESTION_OPEN") &&
          isAlive &&
          !finalLocked;

        if (!shouldFall) {
          const snap = finalHeights?.[myPlayerId];
          return Number.isFinite(snap) ? snap : myFinalHeightBase;
        }

        const dtSec = Math.max(0, (Date.now() - myFinalHeightBaseAt) / 1000);
        const fallen = myFinalHeightBase - FINAL_FALL_RATE_PER_SEC * dtSec;
        return clamp(fallen, 0, 1);
      }

      function tickCountdowns() {
        // Category pick countdown
        if (
          !pickCard.classList.contains("hidden") &&
          Number.isFinite(pickEndsAt)
        ) {
          const left = msLeft(pickEndsAt);
          if (left == null) pickCountdownEl.textContent = "";
          else if (left <= 0) pickCountdownEl.textContent = "Auto-picking‚Ä¶";
          else pickCountdownEl.textContent = `Time left: ${fmtSeconds(left)}`;
        } else {
          pickCountdownEl.textContent = "";
        }

        // Round 1 question countdown
        if (
          !fastestCard.classList.contains("hidden") &&
          Number.isFinite(questionEndsAt)
        ) {
          const left = msLeft(questionEndsAt);
          if (left == null) fastestCountdownEl.textContent = "";
          else if (left <= 0) fastestCountdownEl.textContent = "Time: 0s";
          else fastestCountdownEl.textContent = `Time: ${fmtSeconds(left)}`;
        } else {
          fastestCountdownEl.textContent = "";
        }

        // Final countdown
        if (
          !finalCard.classList.contains("hidden") &&
          Number.isFinite(finalEndsAt)
        ) {
          const left = msLeft(finalEndsAt);
          if (left == null) finalCountdownEl.textContent = "";
          else if (left <= 0) finalCountdownEl.textContent = "Time: 0s";
          else finalCountdownEl.textContent = `Time: ${fmtSeconds(left)}`;
        } else {
          finalCountdownEl.textContent = "";
        }

        // Final: live bar animation
        if (!finalCard.classList.contains("hidden")) {
          setPodiumUI(computeMyLiveFinalHeight());
        }
      }

      setInterval(tickCountdowns, 100);

      function renderPickUI() {
        clearPickUI();
        if (!currentPick) return;

        const chooserId = currentPick.chooserPlayerId;
        const isChooser = !!(
          myPlayerId &&
          chooserId &&
          myPlayerId === chooserId
        );

        if (isChooser) {
          pickHelp.textContent =
            "You're in last place ‚Äî choose the next category:";
        } else {
          const who = currentPick.chooserDisplayName
            ? currentPick.chooserDisplayName
            : "the chooser";
          pickHelp.textContent = `Waiting for ${who} to pick the next category‚Ä¶`;
        }

        const options = normalizeOptions(currentPick.options);

        options.forEach((opt) => {
          const btn = document.createElement("button");
          btn.textContent = opt.name || opt.id;
          btn.disabled = !isChooser || pickLocked;

          btn.addEventListener("click", () => {
            if (!isChooser || pickLocked) return;
            pickLocked = true;

            pickMsg.textContent = "Sending pick‚Ä¶";
            pickOptionsEl
              .querySelectorAll("button")
              .forEach((b) => (b.disabled = true));

            socket.emit(
              "phone:r1_pick_category",
              {
                roomCode: myRoomCode,
                playerId: myPlayerId,
                categoryId: opt.id,
              },
              (ack) => {
                if (!ack?.ok) {
                  pickLocked = false;
                  pickMsg.textContent = `Nope: ${ack?.reason || "UNKNOWN"}`;
                  pickOptionsEl
                    .querySelectorAll("button")
                    .forEach((b) => (b.disabled = false));
                  return;
                }
                pickMsg.textContent = "Picked! Loading next block‚Ä¶";
              }
            );
          });

          pickOptionsEl.appendChild(btn);
        });

        // Prefer server-provided endsAt
        if (Number.isFinite(currentPick.endsAt)) {
          pickEndsAt = currentPick.endsAt;
        } else {
          const t = Number(currentPick.timeoutMs);
          pickEndsAt = Number.isFinite(t) && t > 0 ? Date.now() + t : null;
        }

        if (
          Number.isFinite(currentPick.timeoutMs) &&
          currentPick.timeoutMs > 0
        ) {
          pickMsg.textContent = "Choose quickly (auto-pick when timer hits 0).";
        }
      }

      // --- ANSWER NORMALIZATION (supports more JSON shapes)
      function normalizeAnswersTo4(rawAnswers) {
        const out = [null, null, null, null];
        const idxByLetter = { A: 0, B: 1, C: 2, D: 3 };

        if (!rawAnswers) return out;

        // 1) answers: {A,B,C,D}
        if (
          rawAnswers &&
          typeof rawAnswers === "object" &&
          !Array.isArray(rawAnswers)
        ) {
          const a = rawAnswers.A ?? rawAnswers.a;
          const b = rawAnswers.B ?? rawAnswers.b;
          const c = rawAnswers.C ?? rawAnswers.c;
          const d = rawAnswers.D ?? rawAnswers.d;
          return [a, b, c, d].map((v) => (v == null ? null : String(v)));
        }

        // 2) answers: ["...","...","...","..."]
        if (Array.isArray(rawAnswers)) {
          // If array of strings (or mostly string-ish)
          if (
            rawAnswers.every(
              (x) => typeof x === "string" || typeof x === "number"
            )
          ) {
            return rawAnswers
              .slice(0, 4)
              .map((v) => (v == null ? null : String(v)));
          }

          // If array of objects: [{label:"A", text:"..."}, ...] OR [{text:"..."}, ...]
          for (let i = 0; i < rawAnswers.length; i++) {
            const item = rawAnswers[i];
            if (!item || typeof item !== "object") continue;

            const labelRaw =
              item.label ?? item.letter ?? item.choice ?? item.key ?? null;
            const textRaw =
              item.text ?? item.value ?? item.answer ?? item.name ?? null;

            if (labelRaw) {
              const L = String(labelRaw).trim().toUpperCase();
              if (idxByLetter[L] != null) {
                out[idxByLetter[L]] = textRaw != null ? String(textRaw) : null;
                continue;
              }
            }

            // fallback: positional
            if (i < 4 && out[i] == null) {
              out[i] = textRaw != null ? String(textRaw) : null;
            }
          }

          return out;
        }

        return out;
      }

      function renderAnswerButtonsFromQuestion(rootEl, q) {
        const answers = normalizeAnswersTo4(q?.answers);
        const letters = ["A", "B", "C", "D"];

        letters.forEach((L, i) => {
          // IMPORTANT: scope to the card, not document
          const span = rootEl.querySelector(`[data-txt="${L}"]`);
          if (!span) return;

          const v = answers[i];
          span.textContent =
            v != null && String(v).trim() !== "" ? String(v) : "‚Äî";
        });
      }

      function formatPromptOnly(q) {
        return q?.prompt ? String(q.prompt) : "(question loading‚Ä¶)";
      }

      function isMeLockedOut() {
        if (!fastestState || !myPlayerId) return false;
        const arr = fastestState.lockedOutPlayerIds || [];
        return arr.includes(myPlayerId);
      }

      function hasWinner() {
        return !!(fastestState && fastestState.winner);
      }

      function syncFastestUI() {
        if (fastestCard.classList.contains("hidden")) return;

        if (currentQuestion) {
          questionText.textContent = formatPromptOnly(currentQuestion);
          renderAnswerButtonsFromQuestion(fastestCard, currentQuestion);
        } else {
          questionText.textContent = "(question loading‚Ä¶)";
        }

        if (!fastestState) {
          fastestHeader.textContent = "FASTEST FINGER";
          fastestMsg.textContent = "";
          setChoiceButtonsEnabled(true);
          return;
        }

        if (fastestState.winner) {
          const w = fastestState.winner;
          fastestHeader.textContent = "CLOSED";
          fastestMsg.textContent = `Winner: ${w.displayName || w.playerId} (${
            w.choice || "?"
          })`;
          setChoiceButtonsEnabled(false);
          return;
        }

        if (!fastestState.isOpen) {
          fastestHeader.textContent = "CLOSED";
          fastestMsg.textContent = "";
          setChoiceButtonsEnabled(false);
          return;
        }

        fastestHeader.textContent = "FASTEST FINGER";
        if (isMeLockedOut()) {
          fastestMsg.textContent = "Locked out (wrong answer).";
          setChoiceButtonsEnabled(false);
        } else {
          fastestMsg.textContent = "Tap A / B / C / D ‚Äî first correct wins.";
          setChoiceButtonsEnabled(true);
        }
      }

      function syncFinalUI() {
        if (finalCard.classList.contains("hidden")) return;

        if (finalQuestion) {
          finalQuestionText.textContent = formatPromptOnly(finalQuestion);
          renderAnswerButtonsFromQuestion(finalCard, finalQuestion);
        } else {
          finalQuestionText.textContent = "(question loading‚Ä¶)";
        }

        if (finalLocked) {
          finalMsg.textContent = finalMsg.textContent || "Locked in ‚úÖ";
          setFinalButtonsEnabled(false);
        } else {
          finalMsg.textContent = finalMsg.textContent || "Choose wisely.";
          setFinalButtonsEnabled(true);
        }
      }

      // --------------------
      // Join (first time)
      // --------------------
      btnJoin.addEventListener("click", () => {
        errorEl.textContent = "";

        const roomCode = roomCodeInput.value.trim().toUpperCase();
        const displayName = nameInput.value.trim();

        socket.emit("phone:join_room", { roomCode, displayName }, (ack) => {
          if (!ack?.ok) {
            errorEl.textContent = `Join failed: ${ack?.reason || "UNKNOWN"}`;
            return;
          }

          myRoomCode = ack.roomCode;
          myPlayerId = ack.playerId;
          myPlayerToken = ack.playerToken;
          myAvatarId = ack.avatarId ?? null;

          saveSession(ack.roomCode, ack.displayName, ack.playerToken);

          showOnly(waitingCard);
          joinedLabel.textContent = `Room ${ack.roomCode} ‚Ä¢ Hi ${
            ack.displayName
          }!${myAvatarId ? " [" + myAvatarId + "]" : ""}`;
          setStateLabel(ack.state || "LOBBY");
          applyOptionsToUI();
        });
      });

      // --------------------
      // Auto-rejoin on refresh
      // --------------------
      function tryAutoRejoin() {
        const savedRoom = localStorage.getItem(LS_ROOM);
        const savedName = localStorage.getItem(LS_NAME);
        const savedToken = localStorage.getItem(LS_TOKEN);

        if (!savedRoom || !savedToken) return;

        roomCodeInput.value = savedRoom;
        if (savedName) nameInput.value = savedName;

        errorEl.textContent = "Rejoining game‚Ä¶";
        showOnly(joinCard);

        socket.emit(
          "phone:rejoin_room",
          { roomCode: savedRoom, playerToken: savedToken },
          (ack) => {
            if (!ack?.ok) {
              clearSession();

              if (ack?.reason === "KICKED") {
                errorEl.textContent = "You were kicked from this room.";
              } else {
                errorEl.textContent =
                  "Could not rejoin (game ended or token invalid). Please join again.";
              }

              showOnly(joinCard);
              return;
            }

            myRoomCode = ack.roomCode;
            myPlayerId = ack.playerId;
            myPlayerToken = ack.playerToken;
            myAvatarId = ack.avatarId ?? null;

            saveSession(ack.roomCode, ack.displayName, ack.playerToken);

            showOnly(waitingCard);
            joinedLabel.textContent = `Room ${ack.roomCode} ‚Ä¢ Hi ${
              ack.displayName
            }!${myAvatarId ? " [" + myAvatarId + "]" : ""}`;
            setStateLabel(ack.state || "UNKNOWN");
          }
        );
      }

      // --------------------
      // Options snapshot (authoritative)
      // --------------------
      socket.on("server:options_updated", (payload = {}) => {
        if (payload?.roomCode && myRoomCode && payload.roomCode !== myRoomCode)
          return;

        if (payload?.options) {
          roomOptions = payload.options;
          applyOptionsToUI();
        }
      });

      // --------------------
      // Round 1: Question presented
      // --------------------
      socket.on("server:r1_question_presented", (payload) => {
        const { questionId, prompt, answers } = payload || {};
        currentQuestion = { questionId, prompt, answers };

        showOnly(fastestCard);

        if (Number.isFinite(payload?.endsAt)) questionEndsAt = payload.endsAt;

        if (!fastestState || fastestState.questionId !== questionId) {
          fastestState = {
            questionId,
            isOpen: true,
            winner: null,
            lockedOutPlayerIds: [],
            answeredPlayerIds: [],
          };
        }

        questionText.textContent = formatPromptOnly(currentQuestion);
        renderAnswerButtonsFromQuestion(fastestCard, currentQuestion);
        syncFastestUI();
      });

      // --------------------
      // Round 1: Fastest snapshot state
      // --------------------
      socket.on("server:r1_fastest_state", (payload) => {
        fastestState = payload || null;

        if (payload?.isOpen) showOnly(fastestCard);

        if (Number.isFinite(payload?.endsAt)) questionEndsAt = payload.endsAt;
        else if (payload?.endsAt === null) questionEndsAt = null;

        syncFastestUI();
      });

      // --------------------
      // Round 1: Category pick
      // --------------------
      socket.on("server:r1_category_pick", (payload) => {
        currentPick = {
          chooserPlayerId: payload?.chooserPlayerId ?? null,
          chooserDisplayName: payload?.chooserDisplayName ?? null,
          options: payload?.options || [],
          timeoutMs: payload?.timeoutMs || null,
          endsAt: payload?.endsAt ?? null,
        };

        showOnly(pickCard);
        renderPickUI();
      });

      // --------------------
      // State changes
      // --------------------
      socket.on(
        "server:state_changed",
        ({ state, r1, final, options } = {}) => {
          setStateLabel(state);

          if (options) {
            roomOptions = options;
            applyOptionsToUI();
          }

          const hasSession = !!(myRoomCode || localStorage.getItem(LS_ROOM));
          if (!hasSession) return;

          // Round 1 deadlines
          if (r1) {
            if (Number.isFinite(r1.pickEndsAt)) pickEndsAt = r1.pickEndsAt;
            else if (r1.pickEndsAt === null) pickEndsAt = null;

            if (Number.isFinite(r1.questionEndsAt))
              questionEndsAt = r1.questionEndsAt;
            else if (r1.questionEndsAt === null) questionEndsAt = null;
          }

          // Final snapshot (useful on refresh/rejoin)
          if (final) {
            finalHeights = final.heights || finalHeights;
            finalAliveIds = final.alivePlayerIds || finalAliveIds;
            finalPhase = final.phase || finalPhase;

            if (Number.isFinite(final.endsAt)) finalEndsAt = final.endsAt;
            else if (final.endsAt === null) finalEndsAt = null;

            // Rebuild question if present
            if (final.questionId && (final.prompt || final.answers)) {
              finalQuestion = {
                questionId: final.questionId,
                prompt: final.prompt ?? "",
                answers: final.answers ?? null,
              };
            }
          }

          // Round 1 UI
          if (state === "ROUND_1_CATEGORY_PICK") {
            const detailed = r1?.pickOptionsDetailed;
            const fallback = r1?.pickOptions;

            currentPick = {
              chooserPlayerId: r1?.chooserPlayerId ?? null,
              chooserDisplayName: r1?.chooserDisplayName ?? null,
              options: detailed && detailed.length ? detailed : fallback || [],
              timeoutMs: currentPick?.timeoutMs || null,
              endsAt: Number.isFinite(r1?.pickEndsAt)
                ? r1.pickEndsAt
                : currentPick?.endsAt ?? null,
            };

            showOnly(pickCard);
            renderPickUI();
            return;
          }

          if (state === "ROUND_1_QUESTION_OPEN") {
            showOnly(fastestCard);
            syncFastestUI();
            return;
          }

          // Final UI
          if (state === "FINAL_INTRO") {
            showOnly(waitingCard);
            joinedLabel.textContent = "Final round starting‚Ä¶";
            return;
          }
          if (
            state === "FINAL_QUESTION_OPEN" ||
            state === "FINAL_REVEAL" ||
            state === "FINAL_COMPLETE"
          ) {
            showOnly(finalCard);
            syncFinalUI();
            return;
          }

          // leaving pick/question screens
          currentPick = null;
          clearPickUI();
          pickEndsAt = null;
          questionEndsAt = null;

          if (state === "ROUND_1_INTRO") {
            showOnly(waitingCard);
            joinedLabel.textContent = "Round 1 starting‚Ä¶";
            return;
          }
          if (state === "ROUND_1_COMPLETE") {
            showOnly(waitingCard);
            joinedLabel.textContent = "Round 1 complete!";
            return;
          }

          showOnly(waitingCard);
        }
      );

      // --------------------
      // Round 1: Wrong tap -> locked out
      // --------------------
      socket.on(
        "server:r1_answer_locked_out",
        ({ questionId, answeringPlayerId, chosen, scoreDelta }) => {
          if (!myPlayerId) return;
          if (answeringPlayerId !== myPlayerId) return;

          if (
            questionId &&
            currentQuestion?.questionId &&
            questionId !== currentQuestion.questionId
          )
            return;

          fastestMsg.textContent = `Wrong (${scoreDelta}). Locked out. You chose ${chosen}.`;
          setChoiceButtonsEnabled(false);
        }
      );

      // --------------------
      // Round 1: Winner declared
      // --------------------
      socket.on(
        "server:r1_answer_winner",
        ({
          questionId,
          winnerPlayerId,
          winnerDisplayName,
          chosen,
          scoreDelta,
        }) => {
          if (
            questionId &&
            currentQuestion?.questionId &&
            questionId !== currentQuestion.questionId
          )
            return;

          showOnly(fastestCard);
          fastestHeader.textContent = "CLOSED";

          const who = winnerDisplayName || winnerPlayerId || "Someone";
          fastestMsg.textContent = `Winner: ${who} (${chosen}) (+${scoreDelta})`;
          setChoiceButtonsEnabled(false);

          questionEndsAt = null;
        }
      );

      // --------------------
      // Round 1: Timeout (no winner)
      // --------------------
      socket.on(
        "server:r1_answer_timeout",
        ({ questionId, correctChoice, scoreDeltaIfNoAttempt }) => {
          if (
            questionId &&
            currentQuestion?.questionId &&
            questionId !== currentQuestion.questionId
          )
            return;

          showOnly(fastestCard);
          fastestHeader.textContent = "TIME";
          fastestMsg.textContent = `Time! Correct was ${correctChoice}. (No-attempt penalty ${scoreDeltaIfNoAttempt})`;
          setChoiceButtonsEnabled(false);

          questionEndsAt = null;
        }
      );

      // --------------------
      // Round 1: Tapping an answer
      // --------------------
      fastestCard.querySelectorAll(".choice").forEach((btn) => {
        btn.addEventListener("click", () => {
          const choice = btn.getAttribute("data-choice");
          if (!choice) return;

          if (hasWinner()) return;
          if (isMeLockedOut()) return;

          setChoiceButtonsEnabled(false);
          fastestMsg.textContent = "Sent‚Ä¶";

          socket.emit(
            "phone:r1_answer_tap",
            { roomCode: myRoomCode, playerId: myPlayerId, choice },
            (ack) => {
              if (!ack?.ok) {
                fastestMsg.textContent = `Nope: ${ack?.reason || "UNKNOWN"}`;

                if (
                  ack?.reason === "LOCKED_OUT" ||
                  ack?.reason === "ALREADY_HAS_WINNER" ||
                  ack?.reason === "QUESTION_NOT_OPEN"
                ) {
                  setChoiceButtonsEnabled(false);
                } else {
                  setChoiceButtonsEnabled(true);
                }
              }
            }
          );
        });
      });

      // --------------------
      // FINAL: Question presented
      // --------------------
      socket.on("server:final_question_presented", (payload = {}) => {
        const answersRaw =
          payload.answers ?? payload.options ?? payload.choices ?? null;

        finalQuestion = {
          questionId: payload.questionId ?? null,
          prompt: payload.prompt ?? "",
          answers: answersRaw,
        };

        finalLocked = false;

        finalHeights = payload.heights || finalHeights;
        finalAliveIds = payload.alivePlayerIds || finalAliveIds;
        finalPhase = "question_open";

        // Reset my client-side falling base at question start
        const snap = finalHeights?.[myPlayerId];
        myFinalHeightBase = Number.isFinite(snap) ? snap : 0;
        myFinalHeightBaseAt = Date.now();

        if (Number.isFinite(payload.endsAt)) finalEndsAt = payload.endsAt;
        else finalEndsAt = null;

        finalHeader.textContent = "FINAL PODIUM";
        finalMsg.textContent = "Choose wisely.";
        showOnly(finalCard);

        finalQuestionText.textContent = formatPromptOnly(finalQuestion);
        renderAnswerButtonsFromQuestion(finalCard, finalQuestion);

        setFinalButtonsEnabled(true);
      });

      // --------------------
      // FINAL: server confirms receipt for THIS player
      // --------------------
      socket.on("server:final_answer_received", (payload = {}) => {
        if (!myPlayerId) return;
        if (payload.playerId && payload.playerId !== myPlayerId) return;

        finalLocked = true;
        finalMsg.textContent = "Locked in ‚úÖ";
        setFinalButtonsEnabled(false);

        // Stop falling visually at the height we are now
        const live = computeMyLiveFinalHeight();
        finalHeights[myPlayerId] = live;
        myFinalHeightBase = live;
        myFinalHeightBaseAt = Date.now();
      });

      // --------------------
      // FINAL: Reveal phase
      // --------------------
      socket.on("server:final_reveal", (payload = {}) => {
        finalEndsAt = null;
        finalPhase = "reveal";

        if (payload.heights) finalHeights = payload.heights;
        if (payload.alivePlayerIds) finalAliveIds = payload.alivePlayerIds;

        // Snap my bar to server truth after reveal
        if (myPlayerId && Number.isFinite(finalHeights?.[myPlayerId])) {
          myFinalHeightBase = finalHeights[myPlayerId];
          myFinalHeightBaseAt = Date.now();
        }

        const alive = Array.isArray(payload.alivePlayerIds)
          ? payload.alivePlayerIds.includes(myPlayerId)
          : true;

        finalLocked = true;
        setFinalButtonsEnabled(false);

        if (!alive) {
          finalHeader.textContent = "ELIMINATED";
          finalMsg.textContent = "You fell off üíÄ";
          setPodiumUI(0);
        } else {
          finalMsg.textContent = "Still alive‚Ä¶";
        }
      });

      // --------------------
      // FINAL: Complete
      // --------------------
      socket.on("server:final_complete", (payload = {}) => {
        finalEndsAt = null;
        finalPhase = "complete";

        if (payload.heights) finalHeights = payload.heights;

        if (payload.winnerPlayerId && payload.winnerPlayerId === myPlayerId) {
          finalHeader.textContent = "WINNER";
          finalMsg.textContent = "YOU WIN üéâ";
        } else {
          finalHeader.textContent = "GAME OVER";
          finalMsg.textContent = "Game over.";
        }

        finalLocked = true;
        setFinalButtonsEnabled(false);

        // Snap bar
        const snap = finalHeights?.[myPlayerId];
        setPodiumUI(Number.isFinite(snap) ? snap : 0);
      });

      // --------------------
      // FINAL: Tapping an answer
      // --------------------
      finalCard.querySelectorAll(".finalChoice").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!myRoomCode || !myPlayerId) return;
          if (!finalQuestion || finalLocked) return;

          const choice = btn.getAttribute("data-choice");
          if (!choice) return;

          finalLocked = true;
          finalMsg.textContent = "Locked in‚Ä¶";
          setFinalButtonsEnabled(false);

          // Stop falling visually at the current live height
          const live = computeMyLiveFinalHeight();
          finalHeights[myPlayerId] = live;
          myFinalHeightBase = live;
          myFinalHeightBaseAt = Date.now();

          socket.emit("phone:final_answer_tap", {
            roomCode: myRoomCode,
            playerId: myPlayerId,
            choice,
          });
        });
      });

      // --------------------
      // Kicked by host
      // --------------------
      socket.on("server:player_kicked", (payload = {}) => {
        if (payload?.roomCode && myRoomCode && payload.roomCode !== myRoomCode)
          return;

        clearSession();
        errorEl.textContent = "You were kicked from this room.";
        showOnly(joinCard);
      });

      // --------------------
      // Room closed / errors
      // --------------------
      socket.on("server:error", (err) => {
        if (err?.code === "ROOM_CLOSED") {
          clearSession();
          errorEl.textContent = "Host ended the game.";
          showOnly(joinCard);
          return;
        }

        errorEl.textContent = `Error: ${err?.code || "UNKNOWN"}`;
      });

      // Kick off
      setStateLabel("LOBBY");
      applyOptionsToUI();
      tryAutoRejoin();
    </script>
  </body>
</html>
